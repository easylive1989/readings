<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Readings</title><link>https://easylive1989.github.io/readings/</link><description>Recent content on Readings</description><generator>Hugo -- 0.143.1</generator><language>en</language><lastBuildDate>Mon, 10 Feb 2025 08:50:17 +0800</lastBuildDate><atom:link href="https://easylive1989.github.io/readings/index.xml" rel="self" type="application/rss+xml"/><item><title>Domain model purity vs. domain model completeness (DDD Trilemma)</title><link>https://easylive1989.github.io/readings/backup/domain-model-purity-vs-domain-model-completeness-ddd-trilemma/</link><pubDate>Mon, 10 Feb 2025 08:50:17 +0800</pubDate><guid>https://easylive1989.github.io/readings/backup/domain-model-purity-vs-domain-model-completeness-ddd-trilemma/</guid><description>&lt;p>&lt;a href="https://enterprisecraftsmanship.com/posts/domain-model-purity-completeness/">Source&lt;/a>&lt;/p>
&lt;p>I’ve been meaning to write this article for a long time and, finally, here it is: the topic of domain model purity versus domain model completeness.&lt;/p>
&lt;p>我一直想寫這篇文章，終於完成了！主題是關於領域模型的純粹性與領域模型的完整性。&lt;/p>
&lt;h2 id="domain-model-completeness">Domain model completeness&lt;/h2>
&lt;p>In this article, we’ll talk about a trilemma that comes up in each and every project. In fact, I received a dozen or so questions about this trilemma during the last year or two (slightly embarrassing to realize how long some article ideas spend in my write-up queue).&lt;/p></description></item><item><title>Domain services vs Application Service</title><link>https://easylive1989.github.io/readings/backup/domain-services-vs-application-service/</link><pubDate>Mon, 10 Feb 2025 08:48:57 +0800</pubDate><guid>https://easylive1989.github.io/readings/backup/domain-services-vs-application-service/</guid><description>&lt;p>&lt;a href="https://enterprisecraftsmanship.com/posts/domain-vs-application-services/">Source&lt;/a>&lt;/p>
&lt;p>In this post, we’ll take a look at domain services: what differs them from application services and when it is preferable to use one in addition to an application service.&lt;/p>
&lt;p>在這篇文章中，我們將探討領域服務（Domain Services）：它們與應用服務（Application Services）的區別，以及什麼時候適合在應用服務之外使用領域服務。&lt;/p>
&lt;h2 id="1-domain-services-vs-application-services">1. Domain services vs Application services&lt;/h2>
&lt;p>It is often said that domain services carry domain knowledge that doesn’t naturally fit entities and value objects. There’s another reason, however, why you may want to introduce a domain service. That reason is related to domain model isolation. More on that in just a minute.&lt;/p></description></item><item><title>Entity vs Value Object - the ultimate list of differences</title><link>https://easylive1989.github.io/readings/backup/entity-vs-value-ojbect-the-ultimate-list-of-differences/</link><pubDate>Mon, 10 Feb 2025 08:46:31 +0800</pubDate><guid>https://easylive1989.github.io/readings/backup/entity-vs-value-ojbect-the-ultimate-list-of-differences/</guid><description>&lt;p>&lt;a href="https://enterprisecraftsmanship.com/posts/entity-vs-value-object-the-ultimate-list-of-differences/">Source&lt;/a>&lt;/p>
&lt;p>I wrote about &lt;a href="https://enterprisecraftsmanship.com/2014/11/08/domain-object-base-class/">entities&lt;/a> and &lt;a href="https://enterprisecraftsmanship.com/2015/01/03/value-objects-explained/">value objects&lt;/a> some time ago. In this post, I’d like to talk about differences between Entity vs Value Object in more detail.&lt;/p>
&lt;p>我之前寫過有關&lt;a href="https://enterprisecraftsmanship.com/2014/11/08/domain-object-base-class/">實體 (Entity)&lt;/a>和&lt;a href="https://enterprisecraftsmanship.com/2015/01/03/value-objects-explained/">值物件 (Value Object)&lt;/a>的文章。在這篇文章中，我想更詳細地探討實體與值物件之間的差異。&lt;/p>
&lt;p>I know, the topic isn’t new and there are a lot of articles on the Internet discussing it already. Nevertheless, I didn’t find any with an exhaustive, comprehensive description, so I decided to create my own.&lt;/p>
&lt;p>我知道，這個主題並不新穎，網路上已有許多相關討論的文章。儘管如此，我並未找到任何內容詳盡且全面的描述，因此我決定自己撰寫一篇。&lt;/p>
&lt;h2 id="1-entity-vs-value-object-types-of-equality">1. Entity vs Value Object: types of equality&lt;/h2>
&lt;p>To define the differences between entities and value objects, we need to introduce three types of equality which come into play when we need to compare objects to each other.&lt;/p></description></item><item><title>Story Points Revisited</title><link>https://easylive1989.github.io/readings/backup/story-points-revisited/</link><pubDate>Sat, 08 Feb 2025 21:43:00 +0800</pubDate><guid>https://easylive1989.github.io/readings/backup/story-points-revisited/</guid><description>&lt;p>&lt;a href="https://ronjeffries.com/articles/019-01ff/story-points/Index.html">Source&lt;/a>&lt;/p>
&lt;blockquote>
&lt;p>I like to say that I may have invented story points, and if I did, I’m sorry now. Let’s explore my current thinking on story points. At least one of us is interested in what I think.&lt;/p>
&lt;p>我可能發明了故事點，如果真是如此，我現在感到抱歉。讓我們探討一下我對故事點的最新想法。至少我們中有一個人對我的想法感興趣。&lt;/p>&lt;/blockquote>
&lt;p>Stories, of course, are an XP idea, not a Scrum idea. Somehow, Scrum practitioners have adopted the idea. Even though the official Scrum Guide refers to backlog items, having backlog items be User Stories is a common Scrum practice.&lt;/p></description></item><item><title>Is Design Dead</title><link>https://easylive1989.github.io/readings/backup/is-design-dead/</link><pubDate>Sat, 08 Feb 2025 21:39:18 +0800</pubDate><guid>https://easylive1989.github.io/readings/backup/is-design-dead/</guid><description>&lt;p>&lt;a href="https://martinfowler.com/articles/designDead.html">Source&lt;/a>&lt;/p>
&lt;p>&lt;a href="http://www.extremeprogramming.org/">Extreme Programming&lt;/a> (XP) challenges many of the common assumptions about software development. Of these one of the most controversial is its rejection of significant effort in up-front design, in favor of a more evolutionary approach. To its detractors this is a return to “code and fix” development - usually derided as hacking. To its fans it is often seen as a rejection of design techniques (such as the UML), principles and patterns. Don&amp;rsquo;t worry about design, if you listen to your code a good design will appear.&lt;/p></description></item><item><title>Gui Architectures</title><link>https://easylive1989.github.io/readings/backup/gui-architectures/</link><pubDate>Sat, 08 Feb 2025 21:37:55 +0800</pubDate><guid>https://easylive1989.github.io/readings/backup/gui-architectures/</guid><description>&lt;p>&lt;a href="https://martinfowler.com/eaaDev/uiArchs.html">Source&lt;/a>&lt;/p>
&lt;p>&lt;em>Graphical User Interfaces provide a rich interaction between the user and a software system. Such richness is complex to manage, so it&amp;rsquo;s important to contain that complexity with a thoughtful architecture. The Forms and Controls pattern works well for systems with a simple flow, but as it breaks down under the weight of greater complexity, most people turn to “Model-View-Controller” (MVC). Sadly MVC is one of the most misunderstood architectural patterns around, and systems using that name display a range of important differences, sometimes described under names like Application Model, Model-View-Presenter, Presentation Model, MVVM, and the like. The best way to think of MVC is as set of principles including the separation of presentation from domain logic and synchronizing presentation state through events (the observer pattern).&lt;/em>&lt;/p></description></item><item><title>Cannot Measure Productivity</title><link>https://easylive1989.github.io/readings/backup/cannot-measure-productivity/</link><pubDate>Sat, 08 Feb 2025 21:36:49 +0800</pubDate><guid>https://easylive1989.github.io/readings/backup/cannot-measure-productivity/</guid><description>&lt;p>&lt;a href="https://www.martinfowler.com/bliki/CannotMeasureProductivity.html">Source&lt;/a>&lt;/p>
&lt;p>We see so much emotional discussion about software process, design practices and the like. Many of these arguments are impossible to resolve because the software industry lacks the ability to measure some of the basic elements of the effectiveness of software development. In particular we have no way of reasonably measuring productivity.&lt;/p>
&lt;p>我們經常看到許多關於軟體流程、設計實踐等方面的情緒化討論。其中許多爭論無法解決，因為軟體產業缺乏衡量軟體開發有效性基本要素的能力。特別是，我們無法合理地衡量生產力。&lt;/p>
&lt;p>Productivity, of course, is something you determine by looking at the input of an activity and its output. So to measure software productivity you have to measure the output of software development - the reason we can&amp;rsquo;t measure productivity is because we can&amp;rsquo;t measure output.&lt;/p></description></item><item><title>CQRS</title><link>https://easylive1989.github.io/readings/backup/cqrs/</link><pubDate>Sat, 08 Feb 2025 21:36:02 +0800</pubDate><guid>https://easylive1989.github.io/readings/backup/cqrs/</guid><description>&lt;p>&lt;a href="https://martinfowler.com/bliki/CQRS.html">Source&lt;/a>&lt;/p>
&lt;p>CQRS stands for &lt;strong>Command Query Responsibility Segregation&lt;/strong>. It&amp;rsquo;s a pattern that I first heard described by &lt;a href="https://twitter.com/gregyoung">Greg Young&lt;/a>. At its heart is the notion that you can use a different model to update information than the model you use to read information. For some situations, this separation can be valuable, but beware that for most systems CQRS adds risky complexity.&lt;/p>
&lt;p>CQRS 代表命令查詢責任分離（Command Query Responsibility Segregation）。這是一種由 Greg Young 首次描述的設計模式。其核心理念是，更新資料時可以使用一種模型，而讀取資料時可以使用另一種模型。在某些情況下，這種分離可能非常有價值，但要注意，對於大多數系統而言，CQRS 可能會增加不必要的複雜性和風險。&lt;/p>
&lt;p>The mainstream approach people use for interacting with an information system is to treat it as a CRUD datastore. By this I mean that we have mental model of some record structure where we can &lt;strong>c&lt;/strong>reate new records, &lt;strong>r&lt;/strong>ead records, &lt;strong>u&lt;/strong>pdate existing records, and &lt;strong>d&lt;/strong>elete records when we&amp;rsquo;re done with them. In the simplest case, our interactions are all about storing and retrieving these records.&lt;/p></description></item><item><title>Forest and Desert</title><link>https://easylive1989.github.io/readings/backup/forest-and-desert-martin/</link><pubDate>Sat, 08 Feb 2025 21:34:54 +0800</pubDate><guid>https://easylive1989.github.io/readings/backup/forest-and-desert-martin/</guid><description>&lt;p>&lt;a href="https://martinfowler.com/bliki/ForestAndDesert.html">Source&lt;/a>&lt;/p>
&lt;p>The Forest and the Desert is a metaphor for thinking about software development processes, developed by Beth Andres-Beck and hir father Kent Beck. It posits that two communities of software developers have great difficulty communicating to each other because they live in very different contexts, so advice that applies to one sounds like nonsense to the other.&lt;/p>
&lt;p>《森林與沙漠》是一個用來思考軟體開發流程的隱喻，由 Beth Andres-Beck 與其父 Kent Beck 提出。這個隱喻認為，兩種軟體開發者社群之間的溝通困難重重，因為他們所處的環境截然不同，因此適用於其中一方的建議，對另一方而言往往顯得荒謬無稽。&lt;/p>
&lt;p>The desert is the common world of software development, where bugs are plentiful, skill isn&amp;rsquo;t cultivated, and communications with users is difficult. The forest is the world of a well-run team that uses something like &lt;a href="https://martinfowler.com/bliki/ExtremeProgramming.html">Extreme Programming&lt;/a>, where developers swiftly put changes into production, protected by their tests, code is invested in to keep it healthy, and there is regular contact with The Customer.&lt;/p></description></item><item><title>Naming Standards for Unit Tests</title><link>https://easylive1989.github.io/readings/backup/naming-standards-for-unit-tests/</link><pubDate>Sat, 08 Feb 2025 21:30:20 +0800</pubDate><guid>https://easylive1989.github.io/readings/backup/naming-standards-for-unit-tests/</guid><description>&lt;p>&lt;a href="https://osherove.com/blog/2005/4/3/naming-standards-for-unit-tests.html">Source&lt;/a>&lt;/p>
&lt;p>&lt;em>The basic naming of a test comprises of three main parts:&lt;/em>&lt;/p>
&lt;p>測試名稱的基本結構包含三個主要部分：&lt;/p>
&lt;p> &lt;strong>[UnitOfWork_StateUnderTest_ExpectedBehavior]&lt;/strong>&lt;/p>
&lt;p>A unit of work is a use case in the system that startes with a public method and ends up with one of three types of results: a return value/exception, a state change to the system which changes its behavior, or a call to a third party (when we use mocks). so a unit of work can be a small as a method, or as large as a class, or even multiple classes. as long is it all runs in memory, and is fully under our control.&lt;/p></description></item><item><title>Abstract vs Concrete Parameters</title><link>https://easylive1989.github.io/readings/backup/abstract-vs-concrete-parameters/</link><pubDate>Sat, 08 Feb 2025 16:07:52 +0800</pubDate><guid>https://easylive1989.github.io/readings/backup/abstract-vs-concrete-parameters/</guid><description>&lt;p>&lt;a href="https://tidyfirst.substack.com/p/abstract-vs-concrete-parameters?utm_source=post-email-title&amp;amp;publication_id=256838&amp;amp;post_id=121830629&amp;amp;isFreemail=true&amp;amp;utm_medium=email">Source&lt;/a>&lt;/p>
&lt;p>Originally published August 2008. It’s interesting to me how many of the themes of 15 years ago are still relevant today. I was more down in the programming details then than I usually am today. Let me know if this sort of specific advice helps.&lt;/p>
&lt;p>最初發表於 2008 年 8 月。令我感到有趣的是，15 年前的許多主題至今仍然具有相關性。當時我比現在更深入編程細節。如果這類具體的建議對你有幫助，請告訴我。&lt;/p>
&lt;blockquote>
&lt;p>Easy-to-test software is &amp;ldquo;controllable&amp;rdquo;. Testers can cheaply and accurately simulate the contexts in which the software needs to run. Two contradictory patterns help achieve controllability: making parameters more concrete and more abstract. This apparent contradiction resolves when looked at from a broader perspective.&lt;/p></description></item><item><title>Forest and Desert</title><link>https://easylive1989.github.io/readings/backup/forest-and-desert/</link><pubDate>Sat, 08 Feb 2025 16:06:09 +0800</pubDate><guid>https://easylive1989.github.io/readings/backup/forest-and-desert/</guid><description>&lt;p>&lt;a href="https://tidyfirst.substack.com/p/forest-and-desert">Source&lt;/a>&lt;/p>
&lt;blockquote>
&lt;p>This guest post is written by &lt;a href="https://open.substack.com/users/14841068-beth-andres-beck?utm_source=mentions">Beth Andres-Beck&lt;/a>, following discussions we had preparing for our recent Øredev pair keynote (link to come).&lt;/p>&lt;/blockquote>
&lt;p>“This architecture you’ve described sounds like a lush forest, but we are living in the desert. I don’t see how this will work here.”&lt;/p>
&lt;p>這個架構聽起來像是一片茂密的森林，但我們身處沙漠之中。我看不出來這套做法如何能在這裡運作。&lt;/p>
&lt;p>I am often confronted with skepticism, but seldom is it so constructively put.&lt;/p>
&lt;p>我經常面對質疑，但很少有人能如此具有建設性地表達出來。&lt;/p>
&lt;h2 id="desert">Desert&lt;/h2>
&lt;p>In a software desert, we travel by force of will under an oppressive heat, with saddlebags stuffed to the brim. There is no room for error in the desert, no opportunity for good news, no time to revisit a place we have already been. It is very important that we know how long the journey will take, even when we aren’t sure that where we end up will be any better than where we started.&lt;/p></description></item><item><title>Coupling and Cohension</title><link>https://easylive1989.github.io/readings/backup/coupling-and-cohension/</link><pubDate>Sat, 08 Feb 2025 16:05:34 +0800</pubDate><guid>https://easylive1989.github.io/readings/backup/coupling-and-cohension/</guid><description>&lt;p>&lt;a href="https://tidyfirst.substack.com/p/coupling-and-cohesion">Source&lt;/a>&lt;/p>
&lt;blockquote>
&lt;p>This is from 2009, a mere 4 years into my study of software design. Note that the description of cohesion is nowhere near as crisp as in &lt;em>Tidy First?&lt;/em>. Being able to discuss cohesion clearly was what took me the next 10 years. The only way to be able to describe something well is to describe it badly 100 times.&lt;/p>
&lt;p>這是2009年的一篇文章，那時我才學習軟體設計四年。請注意，對於內聚性的描述遠不如《Tidy First?》一書中的清晰。能夠清楚地討論內聚性花了我接下來的十年時間。能夠很好地描述某件事情的唯一方法就是糟糕地描述它一百次。&lt;/p>&lt;/blockquote>
&lt;p>I just finished a week of training at SKB Kontur in Ekaterinburg, Russia. We covered a lot of ground during the week–TDD, social principles of development, habits for agility. We ended the week talking about software design. During design day we tried to identify the best-designed software there (I recommend this exercise). Because the day was so experiential, we didn’t get to talk about all the design concepts I wanted to discuss. In particular, coupling and cohesion play a central role in the value of software design. As a kind of parting gift to the great group of programmers in the workshop (and because it will bug me if I don’t write it down), here is an introduction to coupling and cohesion.&lt;/p></description></item><item><title>Complain and Propose</title><link>https://easylive1989.github.io/readings/backup/complain-and-propose/</link><pubDate>Sat, 08 Feb 2025 16:04:48 +0800</pubDate><guid>https://easylive1989.github.io/readings/backup/complain-and-propose/</guid><description>&lt;p>&lt;a href="https://tidyfirst.substack.com/p/complain-and-propose">Source&lt;/a>&lt;/p>
&lt;p>&amp;ldquo;Jean-Louis wants to see you in his office.&amp;rdquo; My boss Eagle Burns&amp;rsquo; bald head disappeared from the door to my office. Something about his tone suggested that righteous indignation, which I had been nursing for several days, was not the right attitude to pack for my trip. I started getting scared.&lt;/p>
&lt;p>「Jean-Louis 想在他的辦公室見你。」我的老闆 Eagle Burns 的光頭從我辦公室的門口消失了。他的語氣中透著某種意味，讓我覺得，這幾天我一直抱持的義憤填膺並不是此次旅程該帶上的態度。我開始感到害怕。&lt;/p>
&lt;p>It was Apple 1988.&lt;/p>
&lt;p>那是 1988 年的 Apple。&lt;/p>
&lt;p>Jean-Louis Gassée was head of engineering. He had a reputation as a fire-eater, someone who chewed fools up and spit them out. I had been foolish, it suddenly occurred to me. Do the math.&lt;/p></description></item><item><title>Is Tdd Dead</title><link>https://easylive1989.github.io/readings/backup/is-tdd-dead/</link><pubDate>Sat, 08 Feb 2025 15:52:56 +0800</pubDate><guid>https://easylive1989.github.io/readings/backup/is-tdd-dead/</guid><description>&lt;p>&lt;a href="https://martinfowler.com/articles/is-tdd-dead/">Source&lt;/a>&lt;/p>
&lt;h2 id="where-this-came-from">Where This Came From&lt;/h2>
&lt;p>This conversation began as a consequence to &lt;a href="http://david.heinemeierhansson.com/2014/tdd-is-dead-long-live-testing.html">David’s RailsConf keynote&lt;/a> where he expressed his unhappiness with TDD and Unit Testing in the Rails community. He shortly followed this with some blog posts, the first of which declared that &lt;a href="http://david.heinemeierhansson.com/2014/tdd-is-dead-long-live-testing.html">“TDD is dead”&lt;/a>.&lt;/p>
&lt;p>這段對話始於 David 在 RailsConf 的主題演講中表達了他對 Rails 社區中 TDD 和單元測試的不滿。隨後不久,他發表了一些博客文章,其中第一篇宣稱「TDD 已死」。&lt;/p>
&lt;p>A couple of days after this, I sent him a typo correction to a follow-on post, and he said he’d welcome my thoughts on his talk and blog post. We then had an enjoyable and thoughtful discussion for an hour on Skype. David had a similar discussion with Kent, and Kent suggested that we continue the discussion with all three of us, and make the conversation public. David tweeted the idea and got a lot of positive reactions.&lt;/p></description></item><item><title>Mocks Arent Stubs</title><link>https://easylive1989.github.io/readings/backup/mocks-arent-stubs/</link><pubDate>Sat, 08 Feb 2025 09:28:05 +0800</pubDate><guid>https://easylive1989.github.io/readings/backup/mocks-arent-stubs/</guid><description>&lt;p>&lt;a href="https://martinfowler.com/articles/mocksArentStubs.html">Source&lt;/a>&lt;/p>
&lt;p>The term &amp;lsquo;Mock Objects&amp;rsquo; has become a popular one to describe special case objects that mimic real objects for testing. Most language environments now have frameworks that make it easy to create mock objects. What&amp;rsquo;s often not realized, however, is that mock objects are but one form of special case test object, one that enables a different style of testing. In this article I&amp;rsquo;ll explain how mock objects work, how they encourage testing based on behavior verification, and how the community around them uses them to develop a different style of testing.&lt;/p></description></item><item><title>Test Cancer</title><link>https://easylive1989.github.io/readings/backup/test-cancer/</link><pubDate>Sat, 08 Feb 2025 09:26:48 +0800</pubDate><guid>https://easylive1989.github.io/readings/backup/test-cancer/</guid><description>&lt;p>&lt;a href="https://martinfowler.com/bliki/TestCancer.html">Source&lt;/a>&lt;/p>
&lt;p>As my career has turned into full-time authorship, I often worry about distancing myself from the realities of day-to-day software development. I&amp;rsquo;ve seen other well-known figures lose contact with reality, and I fear the same fate. My greatest source of resistance to this is Thoughtworks, which acts as a regular dose of reality to keep my feet on the ground.&lt;/p>
&lt;p>隨著我的職業生涯逐漸轉向全職作者,我經常擔心自己會脫離日常軟體開發的現實。我見過其他知名人物失去與現實的聯繫,而我也擔心自己會面臨同樣的命運。讓我能抵抗這種命運的最大來源是 Thoughtworks,它定期讓我保持現實感,讓我腳踏實地。&lt;/p>
&lt;p>Thoughtworks also acts as a source of ideas from the field, and I enjoy writing about useful things that my colleagues have discovered and developed. Usually these are helpful ideas, that I hope that some of my readers will be able to use. My topic today isn&amp;rsquo;t such a pleasant topic. It&amp;rsquo;s a problem and one that we don&amp;rsquo;t have an answer for.&lt;/p></description></item><item><title>Tell Dont Ask</title><link>https://easylive1989.github.io/readings/backup/tell-dont-ask/</link><pubDate>Sat, 08 Feb 2025 09:25:28 +0800</pubDate><guid>https://easylive1989.github.io/readings/backup/tell-dont-ask/</guid><description>&lt;p>&lt;a href="https://martinfowler.com/bliki/TellDontAsk.html">Source&lt;/a>&lt;/p>
&lt;p>Tell-Don&amp;rsquo;t-Ask is a principle that helps people remember that object-orientation is about bundling data with the functions that operate on that data. It reminds us that rather than asking an object for data and acting on that data, we should instead tell an object what to do. This encourages to move behavior into an object to go with the data.&lt;/p>
&lt;p>Tell-Don&amp;rsquo;t-Ask 是一個原則，幫助人們記住物件導向是關於將資料與操作該資料的函式捆綁在一起。它提醒我們，與其詢問物件的資料並對該資料進行操作，不如告訴物件要做什麼。這鼓勵將行為移動到與資料相關的物件中。&lt;/p>
&lt;p>&lt;img loading="lazy" src="https://martinfowler.com/bliki/images/tellDontAsk/sketch.png">&lt;/p>
&lt;p>Let&amp;rsquo;s clarify with an example. Let&amp;rsquo;s imagine we need to monitor certain values, signaling an alarm should the value rise above a certain limit. If we write this in an “ask” style, we might have a data structure to represent these things…&lt;/p></description></item><item><title>Unit Test</title><link>https://easylive1989.github.io/readings/backup/unit-test/</link><pubDate>Sat, 08 Feb 2025 09:24:00 +0800</pubDate><guid>https://easylive1989.github.io/readings/backup/unit-test/</guid><description>&lt;p>&lt;a href="https://martinfowler.com/bliki/UnitTest.html">Source&lt;/a>&lt;/p>
&lt;p>Unit testing is often talked about in software development, and is a term that I&amp;rsquo;ve been familiar with during my whole time writing programs. Like most software development terminology, however, it&amp;rsquo;s very ill-defined, and I see confusion can often occur when people think that it&amp;rsquo;s more tightly defined than it actually is.&lt;/p>
&lt;p>單元測試經常在軟體開發中被提及,這是我寫程式時一直熟悉的術語。然而,像大多數軟體開發術語一樣,它的定義非常模糊,我發現當人們認為它的定義比實際更為嚴謹時,往往會引起混淆。&lt;/p>
&lt;p>Although I&amp;rsquo;d done plenty of unit testing before, my definitive exposure was when I started working with Kent Beck and used the Xunit family of unit testing tools. (Indeed I sometimes think a good term for this style of testing might be &amp;ldquo;xunit testing.&amp;rdquo;) Unit testing also became a signature activity of ExtremeProgramming (XP), and led quickly to TestDrivenDevelopment.&lt;/p></description></item><item><title>What if We Rotate Pair Every Day?</title><link>https://easylive1989.github.io/readings/backup/what-if-we-rotate-pair-every-day/</link><pubDate>Sat, 08 Feb 2025 09:02:27 +0800</pubDate><guid>https://easylive1989.github.io/readings/backup/what-if-we-rotate-pair-every-day/</guid><description>&lt;p>&lt;a href="https://martinfowler.com/articles/rotate-pairs-experiment.html">Source&lt;/a>&lt;/p>
&lt;h4 id="unveiling-the-benefits-of-frequent-pair-rotation-through-an-experiment">Unveiling the benefits of frequent pair rotation through an experiment&lt;/h4>
&lt;h4 id="透過實驗揭示頻繁配對輪換的優勢">透過實驗揭示頻繁配對輪換的優勢&lt;/h4>
&lt;p>&lt;em>Benefits of pair programming are widely accepted but advice around pair rotation remains controversial. When and how frequently should teammates rotate pairs? And… What if we rotate pairs every day? We worked with three teams through an exercise of daily pair rotation. We developed a lightweight methodology to help teams reflect on the benefits and challenges of pairing and how to solve them. Initial fears were overcome and teams discovered the benefits of frequently rotating pairs. We learned that pair swapping frequently greatly enhances the benefits of pairing. Here we share the methodology we developed, our observations, and some common fears and insight shared by the participating team members.&lt;/em>&lt;/p></description></item><item><title>One at a Time</title><link>https://easylive1989.github.io/readings/backup/one-at-a-time/</link><pubDate>Sat, 08 Feb 2025 00:00:28 +0800</pubDate><guid>https://easylive1989.github.io/readings/backup/one-at-a-time/</guid><description>&lt;p>&lt;a href="https://tidyfirst.substack.com/p/one-at-a-time">Source&lt;/a>&lt;/p>
&lt;p>Whatever principles I try to live &amp;amp; work by, I try to apply them just as much &amp;amp; as often as possible. Yesterday, though, a lawn chair taught me a valuable lesson about the principle of flow.&lt;/p>
&lt;p>無論我嘗試遵循什麼原則生活和工作，我都盡可能頻繁地應用這些原則。然而，昨天，一把lawn chair教會了我關於流動原則的寶貴一課。&lt;/p>
&lt;p>&lt;img loading="lazy" src="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F80858843-e71f-46e9-ae5e-e5b63ce43e2d_768x576.jpeg">&lt;/p>
&lt;p>The Principle of Flow states that, all else being equal, smaller batches of value more frequently is worth more than that same value delivered in fewer, larger batches. You’ll find the Principle of Flow working every corner of Extreme Programming—software design, planning, testing, integration, deployment, conversations—every corner.&lt;/p></description></item><item><title>Tdd Best Practices</title><link>https://easylive1989.github.io/readings/backup/tdd-best-practices/</link><pubDate>Fri, 07 Feb 2025 17:19:54 +0800</pubDate><guid>https://easylive1989.github.io/readings/backup/tdd-best-practices/</guid><description>&lt;p>&lt;a href="https://enterprisecraftsmanship.com/posts/tdd-best-practices/">Source&lt;/a>&lt;/p>
&lt;p>Last week, we discussed the differences between stubs and mocks. Today, we’ll talk about some general tips and advice that regard to TDD and writing tests in general.&lt;/p>
&lt;ul>
&lt;li>Test-induced design damage or why TDD is so painful&lt;/li>
&lt;li>How to do painless TDD&lt;/li>
&lt;li>Integration testing or how to sleep well at nights&lt;/li>
&lt;li>The most important TDD rule&lt;/li>
&lt;li>Stubs vs Mocks&lt;/li>
&lt;li>&lt;strong>TDD best practices&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h2 id="test-first-vs-code-first-approach">Test-first vs code-first approach&lt;/h2>
&lt;p>There’s some dispute about how exactly tests should be written. While the TDD process itself insists on the test-first approach, I personally think that both ways are applicable in different circumstances. Let’s look at the pros and cons of each of them.&lt;/p></description></item><item><title>Continuous Integration</title><link>https://easylive1989.github.io/readings/backup/continuous-integration/</link><pubDate>Fri, 07 Feb 2025 17:04:50 +0800</pubDate><guid>https://easylive1989.github.io/readings/backup/continuous-integration/</guid><description>&lt;p>&lt;a href="https://www.martinfowler.com/articles/continuousIntegration.html">Source&lt;/a>&lt;/p>
&lt;p>I vividly remember one of my first sightings of a large software project. I was taking a summer internship at a large English electronics company. My manager, part of the QA group, gave me a tour of a site and we entered a huge, depressing, windowless warehouse full of people working in cubicles. I was told that these programmers had been writing code for this software for a couple of years, and while they were done programming, their separate units were now being integrated together, and they had been integrating for several months. My guide told me that nobody really knew how long it would take to finish integrating. From this I learned a common story of software projects: integrating the work
of multiple developers is a long and unpredictable process.&lt;/p></description></item><item><title>Learning in the Forest</title><link>https://easylive1989.github.io/readings/backup/learning-in-the-forest/</link><pubDate>Fri, 07 Feb 2025 16:18:55 +0800</pubDate><guid>https://easylive1989.github.io/readings/backup/learning-in-the-forest/</guid><description>&lt;p>&lt;a href="https://tidyfirst.substack.com/p/learning-in-the-forest?utm_source=post-email-title&amp;amp;publication_id=256838&amp;amp;post_id=151741306&amp;amp;utm_campaign=email-post-title&amp;amp;isFreemail=true&amp;amp;r=qyvh0&amp;amp;triedRedirect=true&amp;amp;utm_medium=email">Source&lt;/a>&lt;/p>
&lt;p>How &amp;amp; why does The Forest emphasize learning over production?&lt;/p>
&lt;p>《森林》如何以及為什麼強調學習重於產出？&lt;/p>
&lt;p>&lt;img loading="lazy" src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F9c18a32f-0673-40ca-9cb1-5cd7ccc0561c_583x220.png">&lt;/p>
&lt;p>Well here you go, thrillfall.&lt;/p>
&lt;p>以下是詳細說明，thrillfall。&lt;/p>
&lt;p>Kent once visited a media tablet project that Dan Ingalls was running (pre-iPad). They were coding in Smalltalk, of course, but they had to port it to their new platform. He was telling me the story of implementing the graphics primitives. Dan had (with Diana Merry-Shapiro) invented BitBLT. Everybody on the team had implemented BitBLT on some platform. Everybody except one. So that person, of course, implemented BitBLT.&lt;/p></description></item><item><title>Cannot Mesure Productivity</title><link>https://easylive1989.github.io/readings/backup/cannot-mesure-productivity/</link><pubDate>Fri, 07 Feb 2025 16:17:38 +0800</pubDate><guid>https://easylive1989.github.io/readings/backup/cannot-mesure-productivity/</guid><description>&lt;p>&lt;a href="https://www.martinfowler.com/bliki/CannotMeasureProductivity.html">Source&lt;/a>&lt;/p>
&lt;p>We see so much emotional discussion about software process, design practices and the like. Many of these arguments are impossible to resolve because the software industry lacks the ability to measure some of the basic elements of the effectiveness of software development. In particular we have no way of reasonably measuring productivity.&lt;/p>
&lt;p>我們經常看到許多關於軟體流程、設計實踐等方面的情緒化討論。其中許多爭論無法解決，因為軟體產業缺乏衡量軟體開發有效性基本要素的能力。特別是，我們無法合理地衡量生產力。&lt;/p>
&lt;p>Productivity, of course, is something you determine by looking at the input of an activity and its output. So to measure software productivity you have to measure the output of software development - the reason we can&amp;rsquo;t measure productivity is because we can&amp;rsquo;t measure output.&lt;/p></description></item><item><title>Bounded Context</title><link>https://easylive1989.github.io/readings/backup/bounded-context/</link><pubDate>Fri, 07 Feb 2025 15:33:58 +0800</pubDate><guid>https://easylive1989.github.io/readings/backup/bounded-context/</guid><description>&lt;p>&lt;a href="https://martinfowler.com/bliki/BoundedContext.html">Source&lt;/a>&lt;/p>
&lt;p>Bounded Context is a central pattern in Domain-Driven Design. It is the focus of DDD&amp;rsquo;s strategic design section which is all about dealing with large models and teams. DDD deals with large models by dividing them into different Bounded Contexts and being explicit about their interrelationships.&lt;/p>
&lt;p>限界上下文（Bounded Context）是領域驅動設計（Domain-Driven Design, DDD）的核心模式。它是 DDD 戰略設計部分的焦點，主要處理大型模型和團隊。DDD 通過將大型模型劃分為不同的限界上下文，並明確定義它們之間的相互關係，來管理這些龐大的模型。&lt;/p>
&lt;p>&lt;img loading="lazy" src="https://martinfowler.com/bliki/images/boundedContext/sketch.png">&lt;/p>
&lt;p>DDD is about designing software based on models of the underlying domain. A model acts as a &lt;a href="https://martinfowler.com/bliki/UbiquitousLanguage.html">UbiquitousLanguage&lt;/a> to help communication between software developers and domain experts. It also acts as the conceptual foundation for the design of the software itself - how it&amp;rsquo;s broken down into objects or functions. To be effective, a model needs to be unified - that is to be internally consistent so that there are no contradictions within it.&lt;/p></description></item></channel></rss>