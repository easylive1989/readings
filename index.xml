<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Readings</title><link>https://easylive1989.github.io/readings/</link><description>Recent content on Readings</description><generator>Hugo -- 0.145.0</generator><language>en</language><lastBuildDate>Sat, 15 Mar 2025 22:48:10 +0800</lastBuildDate><atom:link href="https://easylive1989.github.io/readings/index.xml" rel="self" type="application/rss+xml"/><item><title>The Practical Test Pyramid</title><link>https://easylive1989.github.io/readings/backup/the-practical-test-pyramid/</link><pubDate>Sat, 15 Mar 2025 22:48:10 +0800</pubDate><guid>https://easylive1989.github.io/readings/backup/the-practical-test-pyramid/</guid><description>&lt;p>&lt;a href="https://martinfowler.com/articles/practical-test-pyramid.html">Source&lt;/a>&lt;/p>
&lt;p>&lt;img loading="lazy" src="https://martinfowler.com/articles/practical-test-pyramid/teaser.png">&lt;/p>
&lt;p>Production-ready software requires testing before it goes into production. As the discipline of software development matured, software testing approaches have matured too. Instead of having myriads of manual software testers, development teams have moved towards automating the biggest portion of their testing efforts. Automating their tests allows teams to know whether their software is broken in a matter of seconds and minutes instead of days and weeks.&lt;/p>
&lt;p>產品級軟體在上線前需要經過測試。隨著軟體開發這門學科的成熟，軟體測試方法也日趨成熟。開發團隊已逐漸將測試工作的大部分轉向自動化，而不是依賴大量的軟體手動測試人員。自動化測試使團隊能夠在幾秒或幾分鐘內得知軟體是否損壞，而不是花費數天或數週。&lt;/p></description></item><item><title>Testing Like the TSA</title><link>https://easylive1989.github.io/readings/backup/testing-like-the-tsa/</link><pubDate>Thu, 13 Mar 2025 23:57:10 +0800</pubDate><guid>https://easylive1989.github.io/readings/backup/testing-like-the-tsa/</guid><description>&lt;p>&lt;a href="https://blog.cleancoder.com/uncle-bob/2017/03/06/TestingLikeTheTSA.html">Source&lt;/a>&lt;/p>
&lt;p>I was very glad to read in DHH’s &lt;a href="https://signalvnoise.com/posts/3159-testing-like-the-tsa">recent post&lt;/a> that he is actually still using TDD***. I’m glad he has realized that TDD is not, in fact, &lt;a href="http://david.heinemeierhansson.com/2014/tdd-is-dead-long-live-testing.html">dead&lt;/a>.&lt;/p>
&lt;p>我很高興在 DHH 最近的&lt;a href="https://www.google.com/url?sa=E&amp;amp;q=https%3A%2F%2Fsignalvnoise.com%2Fposts%2F3159-testing-like-the-tsa">文章&lt;/a>中讀到他實際上仍在使用 TDD***。我很高興他意識到 TDD 實際上並沒有&lt;a href="https://www.google.com/url?sa=E&amp;amp;q=http%3A%2F%2Fdavid.heinemeierhansson.com%2F2014%2Ftdd-is-dead-long-live-testing.html">死亡&lt;/a>。&lt;/p>
&lt;p>This blog is a simple response; just to state a couple of disagreements. But I have to say, I agree more than I disagree.&lt;/p>
&lt;p>這篇部落格只是一個簡單的回應；只是為了說明幾個不同意的地方。但我必須說，我同意的地方比不同意的地方還多。&lt;/p>
&lt;p>DHH presented seven points. I have reproduced them below, along with my comments. And since DHH did not justify his opinions, I’ll not justify mine.&lt;/p></description></item><item><title>Test Contra-variance</title><link>https://easylive1989.github.io/readings/backup/test-contra-variance/</link><pubDate>Thu, 13 Mar 2025 23:51:39 +0800</pubDate><guid>https://easylive1989.github.io/readings/backup/test-contra-variance/</guid><description>&lt;p>&lt;a href="https://blog.cleancoder.com/uncle-bob/2017/10/03/TestContravariance.html">Source&lt;/a>&lt;/p>
&lt;p>Do you write unit tests?
你寫單元測試嗎？&lt;/p>
&lt;blockquote>
&lt;p>&lt;em>Yes, of course!&lt;/em>
是的，當然！&lt;/p>&lt;/blockquote>
&lt;p>Do you write them first?
你會先寫單元測試嗎？&lt;/p>
&lt;blockquote>
&lt;p>&lt;em>Yes, I follow &lt;a href="http://www.softwaretestingmagazine.com/knowledge/the-three-rules-of-test-driven-development/">the three laws of TDD&lt;/a>.&lt;/em>
是的，我遵循&lt;a href="https://www.google.com/url?sa=E&amp;amp;q=http%3A%2F%2Fwww.softwaretestingmagazine.com%2Fknowledge%2Fthe-three-rules-of-test-driven-development%2F">TDD 的三個法則&lt;/a>。&lt;/p>&lt;/blockquote>
&lt;p>What is the difference in module structure between your tests and your code?
你的測試和程式碼之間的模組結構有什麼不同？&lt;/p>
&lt;blockquote>
&lt;p>&lt;em>I create one test class per production class.&lt;/em>
我為每個生產類別建立一個測試類別。&lt;/p>&lt;/blockquote>
&lt;p>So if you have a production class named &lt;code>User&lt;/code> you will have a test class named &lt;code>UserTest&lt;/code>?
所以如果你有一個名為 User 的生產類別，你就會有一個名為 UserTest 的測試類別？&lt;/p></description></item><item><title>First-Class Tests</title><link>https://easylive1989.github.io/readings/backup/first-class-tests/</link><pubDate>Thu, 13 Mar 2025 23:29:32 +0800</pubDate><guid>https://easylive1989.github.io/readings/backup/first-class-tests/</guid><description>&lt;p>&lt;a href="https://blog.cleancoder.com/uncle-bob/2017/05/05/TestDefinitions.html">Source&lt;/a>&lt;/p>
&lt;p>I believe it may be my fate to find blogs written by people who have fallen prey to unfortunate disciplines that have led them to give up on unit testing. This blog is just another one of those.&lt;/p>
&lt;p>我相信，我的命運可能就是不斷遇到那些因為不幸的學科而放棄單元測試的人所撰寫的部落格。這篇部落格也只是其中之一。&lt;/p>
&lt;p>The author tells of how his unit tests are fragile because he mocks out all the collaborators. (sigh). Every time a collaborator changes, the mocks have to be changed. And this, of course, makes the unit tests fragile.&lt;/p></description></item><item><title>Getter Eradicator</title><link>https://easylive1989.github.io/readings/backup/getter-eradicator/</link><pubDate>Fri, 28 Feb 2025 02:15:31 +0800</pubDate><guid>https://easylive1989.github.io/readings/backup/getter-eradicator/</guid><description>&lt;p>&lt;a href="https://martinfowler.com/bliki/GetterEradicator.html">Source&lt;/a>&lt;/p>
&lt;p>You can tell them by the twitch in the left hand side of the mouth when they see a getter method, there&amp;rsquo;s swift pull on their battleaxe and a satisfied cry as another getter is hewn unmercifully from a class which immediately swoons in an ecstasy of gratefulness at the manly Getter Eradicator&amp;rsquo;s feet.&lt;/p>
&lt;p>你可以透過他們看到 getter 方法時，左嘴角微微抽動來辨識他們。接著他們會迅速拔出戰斧，並隨著又一個 getter 無情地從類別中被砍除時，發出滿足的呼喊。而這個類別會立即陶醉在感激之情中，拜倒在這位充滿男子氣概的 Getter 消滅者的腳下。&lt;/p>
&lt;p>Alright, maybe my return to English beer is affecting me a bit too much, but Chris&amp;rsquo;s &lt;a href="http://chrisstevenson.me/development/2006/01/10/assertions-on-domain-objects.html">gentle tweak&lt;/a> struck a pet peevlet of mine. I&amp;rsquo;ve often come across people who tell you to avoid having getting methods on classes, treating such things as a violation of encapsulation, &lt;a href="https://www.infoworld.com/article/2073723/why-getter-and-setter-methods-are-evil.html">Allen Holub&amp;rsquo;s article&lt;/a> is one of the best known.&lt;/p></description></item><item><title>Who Needs an Architect?</title><link>https://easylive1989.github.io/readings/backup/who-needs-an-architect/</link><pubDate>Fri, 28 Feb 2025 02:14:11 +0800</pubDate><guid>https://easylive1989.github.io/readings/backup/who-needs-an-architect/</guid><description>&lt;p>&lt;a href="https://martinfowler.com/ieeeSoftware/whoNeedsArchitect.pdf">Source&lt;/a>&lt;/p>
&lt;p>Wandering down our corridor a while ago, I saw my colleague Dave Rice in a particularly grumpy mood. My brief question caused a violent statement, “We shouldn’t interview anyone who has ‘architect’ on his resume.” At first blush, this was an odd turn of phrase, because we usually introduce Dave as one of our leading architects. The reason for his title schizophrenia is the fact that, even by our industry’s standards, “architect” and “architecture” are terribly overloaded words. For many, the term “software architect” fits perfectly with the smug controlling image at the end of Matrix Reloaded. Yet even in firms that have the greatest contempt for that image, there’s a vital role for the technical leadership that an architect such as Dave plays.&lt;/p></description></item><item><title>Interfaces are not abstractions</title><link>https://easylive1989.github.io/readings/backup/interfaces-are-not-abstractions/</link><pubDate>Fri, 28 Feb 2025 02:12:27 +0800</pubDate><guid>https://easylive1989.github.io/readings/backup/interfaces-are-not-abstractions/</guid><description>&lt;p>&lt;a href="https://blog.ploeh.dk/2010/12/02/Interfacesarenotabstractions/">Source&lt;/a>&lt;/p>
&lt;p>One of the first sound bites from the beloved book &lt;a href="http://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612/">Design Patterns&lt;/a> is this:&lt;/p>
&lt;p>《設計模式》（&lt;a href="https://www.google.com/url?sa=E&amp;amp;q=http%3A%2F%2Fwww.amazon.com%2FDesign-Patterns-Elements-Reusable-Object-Oriented%2Fdp%2F0201633612%2F">Design Patterns&lt;/a>）這本經典書籍中，其中一句常被引用的話是：&lt;/p>
&lt;blockquote>
&lt;p>&lt;em>Program to an interface, not an implementation&lt;/em>&lt;/p>
&lt;p>針對介面編程，而不是針對實作編程&lt;/p>&lt;/blockquote>
&lt;p>It would seem that a corollary is that we can measure the quality of our code on the number of interfaces; the more, the better. However, that&amp;rsquo;s not how it feels in reality when you are trying to figure out whether to use an IFooFactory, IFooPolicy, IFooPolicyFactory or perhaps even an IFooFactoryFactory.&lt;/p></description></item><item><title>It's Not Just Standing Up Patterns for Daily Standup Meetings</title><link>https://easylive1989.github.io/readings/backup/its-not-just-standing-up-patterns-for-daily-standup-meetings/</link><pubDate>Sat, 22 Feb 2025 11:00:10 +0800</pubDate><guid>https://easylive1989.github.io/readings/backup/its-not-just-standing-up-patterns-for-daily-standup-meetings/</guid><description>&lt;p>&lt;a href="https://martinfowler.com/articles/itsNotJustStandingUp.html">Source&lt;/a>&lt;/p>
&lt;p>&lt;em>Daily stand-up meetings have become a common ritual of many teams, especially in Agile software development. However, there are many subtle details that distinguish effective stand-ups and a waste of time.&lt;/em>&lt;/p>
&lt;p>每日站立會議已成為許多團隊的常見儀式，尤其是在敏捷軟體開發中。然而，存在許多細微的細節，區分了有效的站立會議和浪費時間的會議。&lt;/p>
&lt;h2 id="we-stand-up-to-keep-the-meeting-short">We stand up to keep the meeting short&lt;/h2>
&lt;p>The daily stand-up meeting (also known as a “daily scrum”, a “daily huddle”, “morning roll-call”, etc.) is simple to describe:&lt;/p>
&lt;p>每日站立會議（也稱為“每日 Scrum”、“每日聚集”、“早點名”等）很容易描述：&lt;/p>
&lt;p>&lt;em>The whole team meets every day for a quick status update. We stand up to keep the meeting short.&lt;/em>&lt;/p></description></item><item><title>On Pair Programming</title><link>https://easylive1989.github.io/readings/backup/on-pair-programming/</link><pubDate>Sat, 22 Feb 2025 10:59:12 +0800</pubDate><guid>https://easylive1989.github.io/readings/backup/on-pair-programming/</guid><description>&lt;p>&lt;a href="https://martinfowler.com/articles/on-pair-programming.html">Source&lt;/a>&lt;/p>
&lt;blockquote>
&lt;p>Betty Snyder and I, from the beginning, were a pair. And I believe that the best programs and designs are done by pairs, because you can criticise each other, and find each others errors, and use the best ideas.
&amp;ndash; &lt;a href="http://www.computerhistory.org/revolution/birth-of-the-computer/4/78/2258">Jean Bartik, one of the very first programmers&lt;/a>&lt;/p>
&lt;p>從一開始，Betty Snyder 和我就是一對。我相信最好的程式和設計都是由兩人合作完成的，因為這樣可以互相批評、找出彼此的錯誤，並採用最好的點子。
—— &lt;a href="http://www.computerhistory.org/revolution/birth-of-the-computer/4/78/2258">Jean Bartik，最早的程式設計師之一&lt;/a>&lt;/p>&lt;/blockquote>
&lt;blockquote>
&lt;p>Write all production programs with two people sitting at one machine.
&amp;ndash; &lt;a href="https://www.amazon.com/gp/product/0321278658/ref=as_li_tl?ie=UTF8&amp;amp;camp=1789&amp;amp;creative=9325&amp;amp;creativeASIN=0321278658&amp;amp;linkCode=as2&amp;amp;tag=martinfowlerc-20">Kent Beck&lt;/a>
所有正式的生產程式都應該由兩個人坐在同一台機器前一起編寫。
—— &lt;a href="https://www.amazon.com/gp/product/0321278658/ref=as_li_tl?ie=UTF8&amp;amp;camp=1789&amp;amp;creative=9325&amp;amp;creativeASIN=0321278658&amp;amp;linkCode=as2&amp;amp;tag=martinfowlerc-20">Kent Beck&lt;/a>&lt;/p></description></item><item><title>How to Develop Software Like Commanding a Tank</title><link>https://easylive1989.github.io/readings/backup/how-to-develop-software-like-commanding-a-tank/</link><pubDate>Mon, 17 Feb 2025 13:23:57 +0800</pubDate><guid>https://easylive1989.github.io/readings/backup/how-to-develop-software-like-commanding-a-tank/</guid><description>&lt;p>&lt;a href="https://gojko.net/2006/10/11/how-to-develop-software-like-commanding-a-tank/">Source&lt;/a>&lt;/p>
&lt;p>In &lt;a href="https://gojko.net/2006/10/07/sources-of-power/">The Sources of Power&lt;/a>, Gary Klein describes his research of variations in understanding orders among commanders and tank platoon leaders, reaching conclusions that giving answers to ‘&lt;em>what&lt;/em>’ and ‘&lt;em>how&lt;/em>’ does not prepare individual teams for reacting to unforeseen problems. As I was reading this, it struck me that this mismatch is also present in software development. Most of the time we get or give answers to ‘&lt;em>how&lt;/em>’ and ‘&lt;em>what&lt;/em>’, and then spend enormous effort on coordination when problems arise, as people start pulling in different directions.&lt;/p></description></item><item><title>From Bugs to Beam</title><link>https://easylive1989.github.io/readings/backup/from-bugs-to-beam/</link><pubDate>Mon, 17 Feb 2025 13:22:58 +0800</pubDate><guid>https://easylive1989.github.io/readings/backup/from-bugs-to-beam/</guid><description>&lt;p>&lt;a href="https://gojko.net/2024/09/30/from-bugs-to-beam/">Source&lt;/a>&lt;/p>
&lt;p>&lt;strong>It’s never been really clear to me what’s the difference between a bug report and a feature request. Yes, of course, there are clear cases at the extremes, but there is a huge gray zone with a lot of overlap. And it recently dawned on me that clearing up this gray zone actually surfaces some very significant product opportunities.&lt;/strong>&lt;/p>
&lt;p>&lt;strong>我一直不太清楚 bug 回報和功能請求之間的區別。當然，在極端情況下是有明顯區別的，但有一個巨大的灰色地帶，兩者之間有很多重疊。我最近才意識到，釐清這個灰色地帶實際上會顯示出一些非常重要的產品機會。&lt;/strong>&lt;/p>
&lt;p>Both bugs and feature requests point to something missing from the product, and that something actually stands in the way of user success. Both need to be analysed, prioritised, developed and tested. Both come with a price tag. And in the words of an old-school project manager I worked with about two decades ago, the major difference is who picks up the bill. “Customers pay for feature requests, but we pay for bugs”, she said. “So make sure that from now on everything possible is a feature request”. Needless to say, that led to some awkward conversations.&lt;/p></description></item><item><title>YAGNI</title><link>https://easylive1989.github.io/readings/backup/yagni/</link><pubDate>Mon, 17 Feb 2025 13:21:44 +0800</pubDate><guid>https://easylive1989.github.io/readings/backup/yagni/</guid><description>&lt;p>&lt;a href="https://martinfowler.com/bliki/Yagni.html">Source&lt;/a>&lt;/p>
&lt;p>Yagni originally is an acronym that stands for “You Aren&amp;rsquo;t Gonna Need It”. It is a mantra from &lt;a href="https://martinfowler.com/bliki/ExtremeProgramming.html">ExtremeProgramming&lt;/a> that&amp;rsquo;s often used generally in agile software teams. It&amp;rsquo;s a statement that some capability we presume our software needs in the future should not be built now because “you aren&amp;rsquo;t gonna need it”.&lt;/p>
&lt;p>Yagni 最初是「You Aren&amp;rsquo;t Gonna Need It」（你不會需要它）的縮寫。這是一個來自&lt;a href="https://martinfowler.com/bliki/ExtremeProgramming.html">極限編程（Extreme Programming, XP）&lt;/a>的口號，在敏捷開發團隊中經常被廣泛使用。它的核心理念是，我們假設軟體未來可能需要某種功能，但現在不應該提前開發，因為「你不會需要它」。&lt;/p>
&lt;p>Yagni is a way to refer to the XP practice of Simple Design (from the first edition of &lt;a href="https://www.amazon.com/gp/product/0321278658/ref=as_li_tl?ie=UTF8&amp;amp;camp=1789&amp;amp;creative=9325&amp;amp;creativeASIN=0321278658&amp;amp;linkCode=as2&amp;amp;tag=martinfowlerc-20">The White Book&lt;/a>, the second edition refers to the related notion of “incremental design”). 1 Like many elements of XP, it&amp;rsquo;s a sharp contrast to elements of the widely held principles of software engineering in the late 90s. At that time there was a big push for careful up-front planning of software development.&lt;/p></description></item><item><title>Keystone Interface</title><link>https://easylive1989.github.io/readings/backup/keystone-interface/</link><pubDate>Mon, 17 Feb 2025 13:21:05 +0800</pubDate><guid>https://easylive1989.github.io/readings/backup/keystone-interface/</guid><description>&lt;p>&lt;a href="https://martinfowler.com/bliki/KeystoneInterface.html">Source&lt;/a>&lt;/p>
&lt;p>Software development teams find life can be much easier if they integrate their work as often as they can. They also find it valuable to release frequently into production. But teams don&amp;rsquo;t want to expose half-developed features to their users. A useful technique to deal with this tension is to build all the back-end code, integrate, but don&amp;rsquo;t build the user-interface. The feature can be integrated and tested, but the UI is held back until the end until, like a keystone, it&amp;rsquo;s added to complete the feature, revealing it to the users.&lt;/p></description></item><item><title>Domain model purity vs. domain model completeness (DDD Trilemma)</title><link>https://easylive1989.github.io/readings/backup/domain-model-purity-vs-domain-model-completeness-ddd-trilemma/</link><pubDate>Mon, 10 Feb 2025 08:50:17 +0800</pubDate><guid>https://easylive1989.github.io/readings/backup/domain-model-purity-vs-domain-model-completeness-ddd-trilemma/</guid><description>&lt;p>&lt;a href="https://enterprisecraftsmanship.com/posts/domain-model-purity-completeness/">Source&lt;/a>&lt;/p>
&lt;p>I’ve been meaning to write this article for a long time and, finally, here it is: the topic of domain model purity versus domain model completeness.&lt;/p>
&lt;p>我一直想寫這篇文章，終於完成了！主題是關於領域模型的純粹性與領域模型的完整性。&lt;/p>
&lt;h2 id="domain-model-completeness">Domain model completeness&lt;/h2>
&lt;p>In this article, we’ll talk about a trilemma that comes up in each and every project. In fact, I received a dozen or so questions about this trilemma during the last year or two (slightly embarrassing to realize how long some article ideas spend in my write-up queue).&lt;/p></description></item><item><title>Domain services vs Application Service</title><link>https://easylive1989.github.io/readings/backup/domain-services-vs-application-service/</link><pubDate>Mon, 10 Feb 2025 08:48:57 +0800</pubDate><guid>https://easylive1989.github.io/readings/backup/domain-services-vs-application-service/</guid><description>&lt;p>&lt;a href="https://enterprisecraftsmanship.com/posts/domain-vs-application-services/">Source&lt;/a>&lt;/p>
&lt;p>In this post, we’ll take a look at domain services: what differs them from application services and when it is preferable to use one in addition to an application service.&lt;/p>
&lt;p>在這篇文章中，我們將探討領域服務（Domain Services）：它們與應用服務（Application Services）的區別，以及什麼時候適合在應用服務之外使用領域服務。&lt;/p>
&lt;h2 id="1-domain-services-vs-application-services">1. Domain services vs Application services&lt;/h2>
&lt;p>It is often said that domain services carry domain knowledge that doesn’t naturally fit entities and value objects. There’s another reason, however, why you may want to introduce a domain service. That reason is related to domain model isolation. More on that in just a minute.&lt;/p></description></item><item><title>Entity vs Value Object - the ultimate list of differences</title><link>https://easylive1989.github.io/readings/backup/entity-vs-value-ojbect-the-ultimate-list-of-differences/</link><pubDate>Mon, 10 Feb 2025 08:46:31 +0800</pubDate><guid>https://easylive1989.github.io/readings/backup/entity-vs-value-ojbect-the-ultimate-list-of-differences/</guid><description>&lt;p>&lt;a href="https://enterprisecraftsmanship.com/posts/entity-vs-value-object-the-ultimate-list-of-differences/">Source&lt;/a>&lt;/p>
&lt;p>I wrote about &lt;a href="https://enterprisecraftsmanship.com/2014/11/08/domain-object-base-class/">entities&lt;/a> and &lt;a href="https://enterprisecraftsmanship.com/2015/01/03/value-objects-explained/">value objects&lt;/a> some time ago. In this post, I’d like to talk about differences between Entity vs Value Object in more detail.&lt;/p>
&lt;p>我之前寫過有關&lt;a href="https://enterprisecraftsmanship.com/2014/11/08/domain-object-base-class/">實體 (Entity)&lt;/a>和&lt;a href="https://enterprisecraftsmanship.com/2015/01/03/value-objects-explained/">值物件 (Value Object)&lt;/a>的文章。在這篇文章中，我想更詳細地探討實體與值物件之間的差異。&lt;/p>
&lt;p>I know, the topic isn’t new and there are a lot of articles on the Internet discussing it already. Nevertheless, I didn’t find any with an exhaustive, comprehensive description, so I decided to create my own.&lt;/p>
&lt;p>我知道，這個主題並不新穎，網路上已有許多相關討論的文章。儘管如此，我並未找到任何內容詳盡且全面的描述，因此我決定自己撰寫一篇。&lt;/p>
&lt;h2 id="1-entity-vs-value-object-types-of-equality">1. Entity vs Value Object: types of equality&lt;/h2>
&lt;p>To define the differences between entities and value objects, we need to introduce three types of equality which come into play when we need to compare objects to each other.&lt;/p></description></item><item><title>Story Points Revisited</title><link>https://easylive1989.github.io/readings/backup/story-points-revisited/</link><pubDate>Sat, 08 Feb 2025 21:43:00 +0800</pubDate><guid>https://easylive1989.github.io/readings/backup/story-points-revisited/</guid><description>&lt;p>&lt;a href="https://ronjeffries.com/articles/019-01ff/story-points/Index.html">Source&lt;/a>&lt;/p>
&lt;blockquote>
&lt;p>I like to say that I may have invented story points, and if I did, I’m sorry now. Let’s explore my current thinking on story points. At least one of us is interested in what I think.&lt;/p>
&lt;p>我可能發明了故事點，如果真是如此，我現在感到抱歉。讓我們探討一下我對故事點的最新想法。至少我們中有一個人對我的想法感興趣。&lt;/p>&lt;/blockquote>
&lt;p>Stories, of course, are an XP idea, not a Scrum idea. Somehow, Scrum practitioners have adopted the idea. Even though the official Scrum Guide refers to backlog items, having backlog items be User Stories is a common Scrum practice.&lt;/p></description></item><item><title>Is Design Dead</title><link>https://easylive1989.github.io/readings/backup/is-design-dead/</link><pubDate>Sat, 08 Feb 2025 21:39:18 +0800</pubDate><guid>https://easylive1989.github.io/readings/backup/is-design-dead/</guid><description>&lt;p>&lt;a href="https://martinfowler.com/articles/designDead.html">Source&lt;/a>&lt;/p>
&lt;p>&lt;a href="http://www.extremeprogramming.org/">Extreme Programming&lt;/a> (XP) challenges many of the common assumptions about software development. Of these one of the most controversial is its rejection of significant effort in up-front design, in favor of a more evolutionary approach. To its detractors this is a return to “code and fix” development - usually derided as hacking. To its fans it is often seen as a rejection of design techniques (such as the UML), principles and patterns. Don&amp;rsquo;t worry about design, if you listen to your code a good design will appear.&lt;/p></description></item><item><title>Gui Architectures</title><link>https://easylive1989.github.io/readings/backup/gui-architectures/</link><pubDate>Sat, 08 Feb 2025 21:37:55 +0800</pubDate><guid>https://easylive1989.github.io/readings/backup/gui-architectures/</guid><description>&lt;p>&lt;a href="https://martinfowler.com/eaaDev/uiArchs.html">Source&lt;/a>&lt;/p>
&lt;p>&lt;em>Graphical User Interfaces provide a rich interaction between the user and a software system. Such richness is complex to manage, so it&amp;rsquo;s important to contain that complexity with a thoughtful architecture. The Forms and Controls pattern works well for systems with a simple flow, but as it breaks down under the weight of greater complexity, most people turn to “Model-View-Controller” (MVC). Sadly MVC is one of the most misunderstood architectural patterns around, and systems using that name display a range of important differences, sometimes described under names like Application Model, Model-View-Presenter, Presentation Model, MVVM, and the like. The best way to think of MVC is as set of principles including the separation of presentation from domain logic and synchronizing presentation state through events (the observer pattern).&lt;/em>&lt;/p></description></item><item><title>Cannot Measure Productivity</title><link>https://easylive1989.github.io/readings/backup/cannot-measure-productivity/</link><pubDate>Sat, 08 Feb 2025 21:36:49 +0800</pubDate><guid>https://easylive1989.github.io/readings/backup/cannot-measure-productivity/</guid><description>&lt;p>&lt;a href="https://www.martinfowler.com/bliki/CannotMeasureProductivity.html">Source&lt;/a>&lt;/p>
&lt;p>We see so much emotional discussion about software process, design practices and the like. Many of these arguments are impossible to resolve because the software industry lacks the ability to measure some of the basic elements of the effectiveness of software development. In particular we have no way of reasonably measuring productivity.&lt;/p>
&lt;p>我們經常看到許多關於軟體流程、設計實踐等方面的情緒化討論。其中許多爭論無法解決，因為軟體產業缺乏衡量軟體開發有效性基本要素的能力。特別是，我們無法合理地衡量生產力。&lt;/p>
&lt;p>Productivity, of course, is something you determine by looking at the input of an activity and its output. So to measure software productivity you have to measure the output of software development - the reason we can&amp;rsquo;t measure productivity is because we can&amp;rsquo;t measure output.&lt;/p></description></item><item><title>CQRS</title><link>https://easylive1989.github.io/readings/backup/cqrs/</link><pubDate>Sat, 08 Feb 2025 21:36:02 +0800</pubDate><guid>https://easylive1989.github.io/readings/backup/cqrs/</guid><description>&lt;p>&lt;a href="https://martinfowler.com/bliki/CQRS.html">Source&lt;/a>&lt;/p>
&lt;p>CQRS stands for &lt;strong>Command Query Responsibility Segregation&lt;/strong>. It&amp;rsquo;s a pattern that I first heard described by &lt;a href="https://twitter.com/gregyoung">Greg Young&lt;/a>. At its heart is the notion that you can use a different model to update information than the model you use to read information. For some situations, this separation can be valuable, but beware that for most systems CQRS adds risky complexity.&lt;/p>
&lt;p>CQRS 代表命令查詢責任分離（Command Query Responsibility Segregation）。這是一種由 Greg Young 首次描述的設計模式。其核心理念是，更新資料時可以使用一種模型，而讀取資料時可以使用另一種模型。在某些情況下，這種分離可能非常有價值，但要注意，對於大多數系統而言，CQRS 可能會增加不必要的複雜性和風險。&lt;/p>
&lt;p>The mainstream approach people use for interacting with an information system is to treat it as a CRUD datastore. By this I mean that we have mental model of some record structure where we can &lt;strong>c&lt;/strong>reate new records, &lt;strong>r&lt;/strong>ead records, &lt;strong>u&lt;/strong>pdate existing records, and &lt;strong>d&lt;/strong>elete records when we&amp;rsquo;re done with them. In the simplest case, our interactions are all about storing and retrieving these records.&lt;/p></description></item><item><title>Forest and Desert</title><link>https://easylive1989.github.io/readings/backup/forest-and-desert-martin/</link><pubDate>Sat, 08 Feb 2025 21:34:54 +0800</pubDate><guid>https://easylive1989.github.io/readings/backup/forest-and-desert-martin/</guid><description>&lt;p>&lt;a href="https://martinfowler.com/bliki/ForestAndDesert.html">Source&lt;/a>&lt;/p>
&lt;p>The Forest and the Desert is a metaphor for thinking about software development processes, developed by Beth Andres-Beck and hir father Kent Beck. It posits that two communities of software developers have great difficulty communicating to each other because they live in very different contexts, so advice that applies to one sounds like nonsense to the other.&lt;/p>
&lt;p>《森林與沙漠》是一個用來思考軟體開發流程的隱喻，由 Beth Andres-Beck 與其父 Kent Beck 提出。這個隱喻認為，兩種軟體開發者社群之間的溝通困難重重，因為他們所處的環境截然不同，因此適用於其中一方的建議，對另一方而言往往顯得荒謬無稽。&lt;/p>
&lt;p>The desert is the common world of software development, where bugs are plentiful, skill isn&amp;rsquo;t cultivated, and communications with users is difficult. The forest is the world of a well-run team that uses something like &lt;a href="https://martinfowler.com/bliki/ExtremeProgramming.html">Extreme Programming&lt;/a>, where developers swiftly put changes into production, protected by their tests, code is invested in to keep it healthy, and there is regular contact with The Customer.&lt;/p></description></item><item><title>Naming Standards for Unit Tests</title><link>https://easylive1989.github.io/readings/backup/naming-standards-for-unit-tests/</link><pubDate>Sat, 08 Feb 2025 21:30:20 +0800</pubDate><guid>https://easylive1989.github.io/readings/backup/naming-standards-for-unit-tests/</guid><description>&lt;p>&lt;a href="https://osherove.com/blog/2005/4/3/naming-standards-for-unit-tests.html">Source&lt;/a>&lt;/p>
&lt;p>&lt;em>The basic naming of a test comprises of three main parts:&lt;/em>&lt;/p>
&lt;p>測試名稱的基本結構包含三個主要部分：&lt;/p>
&lt;p> &lt;strong>[UnitOfWork_StateUnderTest_ExpectedBehavior]&lt;/strong>&lt;/p>
&lt;p>A unit of work is a use case in the system that startes with a public method and ends up with one of three types of results: a return value/exception, a state change to the system which changes its behavior, or a call to a third party (when we use mocks). so a unit of work can be a small as a method, or as large as a class, or even multiple classes. as long is it all runs in memory, and is fully under our control.&lt;/p></description></item><item><title>Abstract vs Concrete Parameters</title><link>https://easylive1989.github.io/readings/backup/abstract-vs-concrete-parameters/</link><pubDate>Sat, 08 Feb 2025 16:07:52 +0800</pubDate><guid>https://easylive1989.github.io/readings/backup/abstract-vs-concrete-parameters/</guid><description>&lt;p>&lt;a href="https://tidyfirst.substack.com/p/abstract-vs-concrete-parameters?utm_source=post-email-title&amp;amp;publication_id=256838&amp;amp;post_id=121830629&amp;amp;isFreemail=true&amp;amp;utm_medium=email">Source&lt;/a>&lt;/p>
&lt;p>Originally published August 2008. It’s interesting to me how many of the themes of 15 years ago are still relevant today. I was more down in the programming details then than I usually am today. Let me know if this sort of specific advice helps.&lt;/p>
&lt;p>最初發表於 2008 年 8 月。令我感到有趣的是，15 年前的許多主題至今仍然具有相關性。當時我比現在更深入編程細節。如果這類具體的建議對你有幫助，請告訴我。&lt;/p>
&lt;blockquote>
&lt;p>Easy-to-test software is &amp;ldquo;controllable&amp;rdquo;. Testers can cheaply and accurately simulate the contexts in which the software needs to run. Two contradictory patterns help achieve controllability: making parameters more concrete and more abstract. This apparent contradiction resolves when looked at from a broader perspective.&lt;/p></description></item><item><title>Forest and Desert</title><link>https://easylive1989.github.io/readings/backup/forest-and-desert/</link><pubDate>Sat, 08 Feb 2025 16:06:09 +0800</pubDate><guid>https://easylive1989.github.io/readings/backup/forest-and-desert/</guid><description>&lt;p>&lt;a href="https://tidyfirst.substack.com/p/forest-and-desert">Source&lt;/a>&lt;/p>
&lt;blockquote>
&lt;p>This guest post is written by &lt;a href="https://open.substack.com/users/14841068-beth-andres-beck?utm_source=mentions">Beth Andres-Beck&lt;/a>, following discussions we had preparing for our recent Øredev pair keynote (link to come).&lt;/p>&lt;/blockquote>
&lt;p>“This architecture you’ve described sounds like a lush forest, but we are living in the desert. I don’t see how this will work here.”&lt;/p>
&lt;p>這個架構聽起來像是一片茂密的森林，但我們身處沙漠之中。我看不出來這套做法如何能在這裡運作。&lt;/p>
&lt;p>I am often confronted with skepticism, but seldom is it so constructively put.&lt;/p>
&lt;p>我經常面對質疑，但很少有人能如此具有建設性地表達出來。&lt;/p>
&lt;h2 id="desert">Desert&lt;/h2>
&lt;p>In a software desert, we travel by force of will under an oppressive heat, with saddlebags stuffed to the brim. There is no room for error in the desert, no opportunity for good news, no time to revisit a place we have already been. It is very important that we know how long the journey will take, even when we aren’t sure that where we end up will be any better than where we started.&lt;/p></description></item><item><title>Coupling and Cohension</title><link>https://easylive1989.github.io/readings/backup/coupling-and-cohension/</link><pubDate>Sat, 08 Feb 2025 16:05:34 +0800</pubDate><guid>https://easylive1989.github.io/readings/backup/coupling-and-cohension/</guid><description>&lt;p>&lt;a href="https://tidyfirst.substack.com/p/coupling-and-cohesion">Source&lt;/a>&lt;/p>
&lt;blockquote>
&lt;p>This is from 2009, a mere 4 years into my study of software design. Note that the description of cohesion is nowhere near as crisp as in &lt;em>Tidy First?&lt;/em>. Being able to discuss cohesion clearly was what took me the next 10 years. The only way to be able to describe something well is to describe it badly 100 times.&lt;/p>
&lt;p>這是2009年的一篇文章，那時我才學習軟體設計四年。請注意，對於內聚性的描述遠不如《Tidy First?》一書中的清晰。能夠清楚地討論內聚性花了我接下來的十年時間。能夠很好地描述某件事情的唯一方法就是糟糕地描述它一百次。&lt;/p>&lt;/blockquote>
&lt;p>I just finished a week of training at SKB Kontur in Ekaterinburg, Russia. We covered a lot of ground during the week–TDD, social principles of development, habits for agility. We ended the week talking about software design. During design day we tried to identify the best-designed software there (I recommend this exercise). Because the day was so experiential, we didn’t get to talk about all the design concepts I wanted to discuss. In particular, coupling and cohesion play a central role in the value of software design. As a kind of parting gift to the great group of programmers in the workshop (and because it will bug me if I don’t write it down), here is an introduction to coupling and cohesion.&lt;/p></description></item><item><title>Complain and Propose</title><link>https://easylive1989.github.io/readings/backup/complain-and-propose/</link><pubDate>Sat, 08 Feb 2025 16:04:48 +0800</pubDate><guid>https://easylive1989.github.io/readings/backup/complain-and-propose/</guid><description>&lt;p>&lt;a href="https://tidyfirst.substack.com/p/complain-and-propose">Source&lt;/a>&lt;/p>
&lt;p>&amp;ldquo;Jean-Louis wants to see you in his office.&amp;rdquo; My boss Eagle Burns&amp;rsquo; bald head disappeared from the door to my office. Something about his tone suggested that righteous indignation, which I had been nursing for several days, was not the right attitude to pack for my trip. I started getting scared.&lt;/p>
&lt;p>「Jean-Louis 想在他的辦公室見你。」我的老闆 Eagle Burns 的光頭從我辦公室的門口消失了。他的語氣中透著某種意味，讓我覺得，這幾天我一直抱持的義憤填膺並不是此次旅程該帶上的態度。我開始感到害怕。&lt;/p>
&lt;p>It was Apple 1988.&lt;/p>
&lt;p>那是 1988 年的 Apple。&lt;/p>
&lt;p>Jean-Louis Gassée was head of engineering. He had a reputation as a fire-eater, someone who chewed fools up and spit them out. I had been foolish, it suddenly occurred to me. Do the math.&lt;/p></description></item><item><title>Is Tdd Dead</title><link>https://easylive1989.github.io/readings/backup/is-tdd-dead/</link><pubDate>Sat, 08 Feb 2025 15:52:56 +0800</pubDate><guid>https://easylive1989.github.io/readings/backup/is-tdd-dead/</guid><description>&lt;p>&lt;a href="https://martinfowler.com/articles/is-tdd-dead/">Source&lt;/a>&lt;/p>
&lt;h2 id="where-this-came-from">Where This Came From&lt;/h2>
&lt;p>This conversation began as a consequence to &lt;a href="http://david.heinemeierhansson.com/2014/tdd-is-dead-long-live-testing.html">David’s RailsConf keynote&lt;/a> where he expressed his unhappiness with TDD and Unit Testing in the Rails community. He shortly followed this with some blog posts, the first of which declared that &lt;a href="http://david.heinemeierhansson.com/2014/tdd-is-dead-long-live-testing.html">“TDD is dead”&lt;/a>.&lt;/p>
&lt;p>這段對話始於 David 在 RailsConf 的主題演講中表達了他對 Rails 社區中 TDD 和單元測試的不滿。隨後不久,他發表了一些博客文章,其中第一篇宣稱「TDD 已死」。&lt;/p>
&lt;p>A couple of days after this, I sent him a typo correction to a follow-on post, and he said he’d welcome my thoughts on his talk and blog post. We then had an enjoyable and thoughtful discussion for an hour on Skype. David had a similar discussion with Kent, and Kent suggested that we continue the discussion with all three of us, and make the conversation public. David tweeted the idea and got a lot of positive reactions.&lt;/p></description></item><item><title>Mocks Arent Stubs</title><link>https://easylive1989.github.io/readings/backup/mocks-arent-stubs/</link><pubDate>Sat, 08 Feb 2025 09:28:05 +0800</pubDate><guid>https://easylive1989.github.io/readings/backup/mocks-arent-stubs/</guid><description>&lt;p>&lt;a href="https://martinfowler.com/articles/mocksArentStubs.html">Source&lt;/a>&lt;/p>
&lt;p>The term &amp;lsquo;Mock Objects&amp;rsquo; has become a popular one to describe special case objects that mimic real objects for testing. Most language environments now have frameworks that make it easy to create mock objects. What&amp;rsquo;s often not realized, however, is that mock objects are but one form of special case test object, one that enables a different style of testing. In this article I&amp;rsquo;ll explain how mock objects work, how they encourage testing based on behavior verification, and how the community around them uses them to develop a different style of testing.&lt;/p></description></item><item><title>Test Cancer</title><link>https://easylive1989.github.io/readings/backup/test-cancer/</link><pubDate>Sat, 08 Feb 2025 09:26:48 +0800</pubDate><guid>https://easylive1989.github.io/readings/backup/test-cancer/</guid><description>&lt;p>&lt;a href="https://martinfowler.com/bliki/TestCancer.html">Source&lt;/a>&lt;/p>
&lt;p>As my career has turned into full-time authorship, I often worry about distancing myself from the realities of day-to-day software development. I&amp;rsquo;ve seen other well-known figures lose contact with reality, and I fear the same fate. My greatest source of resistance to this is Thoughtworks, which acts as a regular dose of reality to keep my feet on the ground.&lt;/p>
&lt;p>隨著我的職業生涯逐漸轉向全職作者,我經常擔心自己會脫離日常軟體開發的現實。我見過其他知名人物失去與現實的聯繫,而我也擔心自己會面臨同樣的命運。讓我能抵抗這種命運的最大來源是 Thoughtworks,它定期讓我保持現實感,讓我腳踏實地。&lt;/p>
&lt;p>Thoughtworks also acts as a source of ideas from the field, and I enjoy writing about useful things that my colleagues have discovered and developed. Usually these are helpful ideas, that I hope that some of my readers will be able to use. My topic today isn&amp;rsquo;t such a pleasant topic. It&amp;rsquo;s a problem and one that we don&amp;rsquo;t have an answer for.&lt;/p></description></item><item><title>Tell Dont Ask</title><link>https://easylive1989.github.io/readings/backup/tell-dont-ask/</link><pubDate>Sat, 08 Feb 2025 09:25:28 +0800</pubDate><guid>https://easylive1989.github.io/readings/backup/tell-dont-ask/</guid><description>&lt;p>&lt;a href="https://martinfowler.com/bliki/TellDontAsk.html">Source&lt;/a>&lt;/p>
&lt;p>Tell-Don&amp;rsquo;t-Ask is a principle that helps people remember that object-orientation is about bundling data with the functions that operate on that data. It reminds us that rather than asking an object for data and acting on that data, we should instead tell an object what to do. This encourages to move behavior into an object to go with the data.&lt;/p>
&lt;p>Tell-Don&amp;rsquo;t-Ask 是一個原則，幫助人們記住物件導向是關於將資料與操作該資料的函式捆綁在一起。它提醒我們，與其詢問物件的資料並對該資料進行操作，不如告訴物件要做什麼。這鼓勵將行為移動到與資料相關的物件中。&lt;/p>
&lt;p>&lt;img loading="lazy" src="https://martinfowler.com/bliki/images/tellDontAsk/sketch.png">&lt;/p>
&lt;p>Let&amp;rsquo;s clarify with an example. Let&amp;rsquo;s imagine we need to monitor certain values, signaling an alarm should the value rise above a certain limit. If we write this in an “ask” style, we might have a data structure to represent these things…&lt;/p></description></item><item><title>Unit Test</title><link>https://easylive1989.github.io/readings/backup/unit-test/</link><pubDate>Sat, 08 Feb 2025 09:24:00 +0800</pubDate><guid>https://easylive1989.github.io/readings/backup/unit-test/</guid><description>&lt;p>&lt;a href="https://martinfowler.com/bliki/UnitTest.html">Source&lt;/a>&lt;/p>
&lt;p>Unit testing is often talked about in software development, and is a term that I&amp;rsquo;ve been familiar with during my whole time writing programs. Like most software development terminology, however, it&amp;rsquo;s very ill-defined, and I see confusion can often occur when people think that it&amp;rsquo;s more tightly defined than it actually is.&lt;/p>
&lt;p>單元測試經常在軟體開發中被提及,這是我寫程式時一直熟悉的術語。然而,像大多數軟體開發術語一樣,它的定義非常模糊,我發現當人們認為它的定義比實際更為嚴謹時,往往會引起混淆。&lt;/p>
&lt;p>Although I&amp;rsquo;d done plenty of unit testing before, my definitive exposure was when I started working with Kent Beck and used the Xunit family of unit testing tools. (Indeed I sometimes think a good term for this style of testing might be &amp;ldquo;xunit testing.&amp;rdquo;) Unit testing also became a signature activity of ExtremeProgramming (XP), and led quickly to TestDrivenDevelopment.&lt;/p></description></item><item><title>What if We Rotate Pair Every Day?</title><link>https://easylive1989.github.io/readings/backup/what-if-we-rotate-pair-every-day/</link><pubDate>Sat, 08 Feb 2025 09:02:27 +0800</pubDate><guid>https://easylive1989.github.io/readings/backup/what-if-we-rotate-pair-every-day/</guid><description>&lt;p>&lt;a href="https://martinfowler.com/articles/rotate-pairs-experiment.html">Source&lt;/a>&lt;/p>
&lt;h4 id="unveiling-the-benefits-of-frequent-pair-rotation-through-an-experiment">Unveiling the benefits of frequent pair rotation through an experiment&lt;/h4>
&lt;h4 id="透過實驗揭示頻繁配對輪換的優勢">透過實驗揭示頻繁配對輪換的優勢&lt;/h4>
&lt;p>&lt;em>Benefits of pair programming are widely accepted but advice around pair rotation remains controversial. When and how frequently should teammates rotate pairs? And… What if we rotate pairs every day? We worked with three teams through an exercise of daily pair rotation. We developed a lightweight methodology to help teams reflect on the benefits and challenges of pairing and how to solve them. Initial fears were overcome and teams discovered the benefits of frequently rotating pairs. We learned that pair swapping frequently greatly enhances the benefits of pairing. Here we share the methodology we developed, our observations, and some common fears and insight shared by the participating team members.&lt;/em>&lt;/p></description></item><item><title>One at a Time</title><link>https://easylive1989.github.io/readings/backup/one-at-a-time/</link><pubDate>Sat, 08 Feb 2025 00:00:28 +0800</pubDate><guid>https://easylive1989.github.io/readings/backup/one-at-a-time/</guid><description>&lt;p>&lt;a href="https://tidyfirst.substack.com/p/one-at-a-time">Source&lt;/a>&lt;/p>
&lt;p>Whatever principles I try to live &amp;amp; work by, I try to apply them just as much &amp;amp; as often as possible. Yesterday, though, a lawn chair taught me a valuable lesson about the principle of flow.&lt;/p>
&lt;p>無論我嘗試遵循什麼原則生活和工作，我都盡可能頻繁地應用這些原則。然而，昨天，一把lawn chair教會了我關於流動原則的寶貴一課。&lt;/p>
&lt;p>&lt;img loading="lazy" src="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F80858843-e71f-46e9-ae5e-e5b63ce43e2d_768x576.jpeg">&lt;/p>
&lt;p>The Principle of Flow states that, all else being equal, smaller batches of value more frequently is worth more than that same value delivered in fewer, larger batches. You’ll find the Principle of Flow working every corner of Extreme Programming—software design, planning, testing, integration, deployment, conversations—every corner.&lt;/p></description></item><item><title>Tdd Best Practices</title><link>https://easylive1989.github.io/readings/backup/tdd-best-practices/</link><pubDate>Fri, 07 Feb 2025 17:19:54 +0800</pubDate><guid>https://easylive1989.github.io/readings/backup/tdd-best-practices/</guid><description>&lt;p>&lt;a href="https://enterprisecraftsmanship.com/posts/tdd-best-practices/">Source&lt;/a>&lt;/p>
&lt;p>Last week, we discussed the differences between stubs and mocks. Today, we’ll talk about some general tips and advice that regard to TDD and writing tests in general.&lt;/p>
&lt;ul>
&lt;li>Test-induced design damage or why TDD is so painful&lt;/li>
&lt;li>How to do painless TDD&lt;/li>
&lt;li>Integration testing or how to sleep well at nights&lt;/li>
&lt;li>The most important TDD rule&lt;/li>
&lt;li>Stubs vs Mocks&lt;/li>
&lt;li>&lt;strong>TDD best practices&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h2 id="test-first-vs-code-first-approach">Test-first vs code-first approach&lt;/h2>
&lt;p>There’s some dispute about how exactly tests should be written. While the TDD process itself insists on the test-first approach, I personally think that both ways are applicable in different circumstances. Let’s look at the pros and cons of each of them.&lt;/p></description></item><item><title>Continuous Integration</title><link>https://easylive1989.github.io/readings/backup/continuous-integration/</link><pubDate>Fri, 07 Feb 2025 17:04:50 +0800</pubDate><guid>https://easylive1989.github.io/readings/backup/continuous-integration/</guid><description>&lt;p>&lt;a href="https://www.martinfowler.com/articles/continuousIntegration.html">Source&lt;/a>&lt;/p>
&lt;p>I vividly remember one of my first sightings of a large software project. I was taking a summer internship at a large English electronics company. My manager, part of the QA group, gave me a tour of a site and we entered a huge, depressing, windowless warehouse full of people working in cubicles. I was told that these programmers had been writing code for this software for a couple of years, and while they were done programming, their separate units were now being integrated together, and they had been integrating for several months. My guide told me that nobody really knew how long it would take to finish integrating. From this I learned a common story of software projects: integrating the work
of multiple developers is a long and unpredictable process.&lt;/p></description></item><item><title>Learning in the Forest</title><link>https://easylive1989.github.io/readings/backup/learning-in-the-forest/</link><pubDate>Fri, 07 Feb 2025 16:18:55 +0800</pubDate><guid>https://easylive1989.github.io/readings/backup/learning-in-the-forest/</guid><description>&lt;p>&lt;a href="https://tidyfirst.substack.com/p/learning-in-the-forest?utm_source=post-email-title&amp;amp;publication_id=256838&amp;amp;post_id=151741306&amp;amp;utm_campaign=email-post-title&amp;amp;isFreemail=true&amp;amp;r=qyvh0&amp;amp;triedRedirect=true&amp;amp;utm_medium=email">Source&lt;/a>&lt;/p>
&lt;p>How &amp;amp; why does The Forest emphasize learning over production?&lt;/p>
&lt;p>《森林》如何以及為什麼強調學習重於產出？&lt;/p>
&lt;p>&lt;img loading="lazy" src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F9c18a32f-0673-40ca-9cb1-5cd7ccc0561c_583x220.png">&lt;/p>
&lt;p>Well here you go, thrillfall.&lt;/p>
&lt;p>以下是詳細說明，thrillfall。&lt;/p>
&lt;p>Kent once visited a media tablet project that Dan Ingalls was running (pre-iPad). They were coding in Smalltalk, of course, but they had to port it to their new platform. He was telling me the story of implementing the graphics primitives. Dan had (with Diana Merry-Shapiro) invented BitBLT. Everybody on the team had implemented BitBLT on some platform. Everybody except one. So that person, of course, implemented BitBLT.&lt;/p></description></item><item><title>Cannot Mesure Productivity</title><link>https://easylive1989.github.io/readings/backup/cannot-mesure-productivity/</link><pubDate>Fri, 07 Feb 2025 16:17:38 +0800</pubDate><guid>https://easylive1989.github.io/readings/backup/cannot-mesure-productivity/</guid><description>&lt;p>&lt;a href="https://www.martinfowler.com/bliki/CannotMeasureProductivity.html">Source&lt;/a>&lt;/p>
&lt;p>We see so much emotional discussion about software process, design practices and the like. Many of these arguments are impossible to resolve because the software industry lacks the ability to measure some of the basic elements of the effectiveness of software development. In particular we have no way of reasonably measuring productivity.&lt;/p>
&lt;p>我們經常看到許多關於軟體流程、設計實踐等方面的情緒化討論。其中許多爭論無法解決，因為軟體產業缺乏衡量軟體開發有效性基本要素的能力。特別是，我們無法合理地衡量生產力。&lt;/p>
&lt;p>Productivity, of course, is something you determine by looking at the input of an activity and its output. So to measure software productivity you have to measure the output of software development - the reason we can&amp;rsquo;t measure productivity is because we can&amp;rsquo;t measure output.&lt;/p></description></item><item><title>Bounded Context</title><link>https://easylive1989.github.io/readings/backup/bounded-context/</link><pubDate>Fri, 07 Feb 2025 15:33:58 +0800</pubDate><guid>https://easylive1989.github.io/readings/backup/bounded-context/</guid><description>&lt;p>&lt;a href="https://martinfowler.com/bliki/BoundedContext.html">Source&lt;/a>&lt;/p>
&lt;p>Bounded Context is a central pattern in Domain-Driven Design. It is the focus of DDD&amp;rsquo;s strategic design section which is all about dealing with large models and teams. DDD deals with large models by dividing them into different Bounded Contexts and being explicit about their interrelationships.&lt;/p>
&lt;p>限界上下文（Bounded Context）是領域驅動設計（Domain-Driven Design, DDD）的核心模式。它是 DDD 戰略設計部分的焦點，主要處理大型模型和團隊。DDD 通過將大型模型劃分為不同的限界上下文，並明確定義它們之間的相互關係，來管理這些龐大的模型。&lt;/p>
&lt;p>&lt;img loading="lazy" src="https://martinfowler.com/bliki/images/boundedContext/sketch.png">&lt;/p>
&lt;p>DDD is about designing software based on models of the underlying domain. A model acts as a &lt;a href="https://martinfowler.com/bliki/UbiquitousLanguage.html">UbiquitousLanguage&lt;/a> to help communication between software developers and domain experts. It also acts as the conceptual foundation for the design of the software itself - how it&amp;rsquo;s broken down into objects or functions. To be effective, a model needs to be unified - that is to be internally consistent so that there are no contradictions within it.&lt;/p></description></item></channel></rss>