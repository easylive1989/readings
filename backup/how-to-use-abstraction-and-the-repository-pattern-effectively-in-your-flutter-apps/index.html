<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>How to Use Abstraction and the Repository Pattern Effectively in Your Flutter Apps | Readings</title>
<meta name=keywords content="Andrea Bizzotto"><meta name=description content="Source
If your Flutter app talks to a backend or some server-side APIs, youâ€™ll want to have a goodÂ separation of concernsÂ between the UI code and your data-access layer.
å¦‚æœä½ çš„ Flutter æ‡‰ç”¨ç¨‹å¼éœ€è¦èˆ‡å¾Œç«¯æˆ–æŸäº›ä¼ºæœå™¨ç«¯ API é€šè¨Šï¼Œä½ æœƒå¸Œæœ›åœ¨ UI ä»£ç¢¼å’Œè³‡æ–™å­˜å–å±¤ä¹‹é–“æœ‰è‰¯å¥½çš„è²¬ä»»åˆ†é›¢ã€‚
A very good way to do this is to use theÂ repository pattern, which lets you encapsulate all the data access logic (serialization, networking) inside a single class (the repository).
ä¸€å€‹éå¸¸å¥½çš„æ–¹æ³•æ˜¯ä½¿ç”¨å„²å­˜åº«æ¨¡å¼ (repository pattern)ï¼Œé€™ç¨®æ¨¡å¼è®“ä½ å¯ä»¥å°‡æ‰€æœ‰è³‡æ–™å­˜å–é‚è¼¯ï¼ˆå¦‚åºåˆ—åŒ–ã€ç¶²è·¯è«‹æ±‚ï¼‰å°è£åœ¨ä¸€å€‹é¡åˆ¥ï¼ˆå„²å­˜åº«ï¼‰ä¸­ã€‚
The benefit is that the rest of your app only communicates to theÂ public interfaceÂ of that repository and doesnâ€™t need to know about all its implementation details (such as what 3rd party APIs are used under the hood)."><meta name=author content><link rel=canonical href=https://easylive1989.github.io/readings/backup/how-to-use-abstraction-and-the-repository-pattern-effectively-in-your-flutter-apps/><link crossorigin=anonymous href=/readings/assets/css/stylesheet.45e028aa8ce0961349adf411b013ee39406be2c0bc80d4ea3fc04555f7f4611a.css integrity="sha256-ReAoqozglhNJrfQRsBPuOUBr4sC8gNTqP8BFVff0YRo=" rel="preload stylesheet" as=style><link rel=icon href=https://easylive1989.github.io/readings/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://easylive1989.github.io/readings/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://easylive1989.github.io/readings/favicon-32x32.png><link rel=apple-touch-icon href=https://easylive1989.github.io/readings/apple-touch-icon.png><link rel=mask-icon href=https://easylive1989.github.io/readings/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://easylive1989.github.io/readings/backup/how-to-use-abstraction-and-the-repository-pattern-effectively-in-your-flutter-apps/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://easylive1989.github.io/readings/backup/how-to-use-abstraction-and-the-repository-pattern-effectively-in-your-flutter-apps/"><meta property="og:site_name" content="Readings"><meta property="og:title" content="How to Use Abstraction and the Repository Pattern Effectively in Your Flutter Apps"><meta property="og:description" content="Source
If your Flutter app talks to a backend or some server-side APIs, youâ€™ll want to have a goodÂ separation of concernsÂ between the UI code and your data-access layer.
å¦‚æœä½ çš„ Flutter æ‡‰ç”¨ç¨‹å¼éœ€è¦èˆ‡å¾Œç«¯æˆ–æŸäº›ä¼ºæœå™¨ç«¯ API é€šè¨Šï¼Œä½ æœƒå¸Œæœ›åœ¨ UI ä»£ç¢¼å’Œè³‡æ–™å­˜å–å±¤ä¹‹é–“æœ‰è‰¯å¥½çš„è²¬ä»»åˆ†é›¢ã€‚
A very good way to do this is to use theÂ repository pattern, which lets you encapsulate all the data access logic (serialization, networking) inside a single class (the repository).
ä¸€å€‹éå¸¸å¥½çš„æ–¹æ³•æ˜¯ä½¿ç”¨å„²å­˜åº«æ¨¡å¼ (repository pattern)ï¼Œé€™ç¨®æ¨¡å¼è®“ä½ å¯ä»¥å°‡æ‰€æœ‰è³‡æ–™å­˜å–é‚è¼¯ï¼ˆå¦‚åºåˆ—åŒ–ã€ç¶²è·¯è«‹æ±‚ï¼‰å°è£åœ¨ä¸€å€‹é¡åˆ¥ï¼ˆå„²å­˜åº«ï¼‰ä¸­ã€‚
The benefit is that the rest of your app only communicates to theÂ public interfaceÂ of that repository and doesnâ€™t need to know about all its implementation details (such as what 3rd party APIs are used under the hood)."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="backup"><meta property="article:published_time" content="2025-04-05T23:18:28+08:00"><meta property="article:modified_time" content="2025-04-05T23:18:28+08:00"><meta property="article:tag" content="Andrea Bizzotto"><meta name=twitter:card content="summary"><meta name=twitter:title content="How to Use Abstraction and the Repository Pattern Effectively in Your Flutter Apps"><meta name=twitter:description content="Source
If your Flutter app talks to a backend or some server-side APIs, youâ€™ll want to have a goodÂ separation of concernsÂ between the UI code and your data-access layer.
å¦‚æœä½ çš„ Flutter æ‡‰ç”¨ç¨‹å¼éœ€è¦èˆ‡å¾Œç«¯æˆ–æŸäº›ä¼ºæœå™¨ç«¯ API é€šè¨Šï¼Œä½ æœƒå¸Œæœ›åœ¨ UI ä»£ç¢¼å’Œè³‡æ–™å­˜å–å±¤ä¹‹é–“æœ‰è‰¯å¥½çš„è²¬ä»»åˆ†é›¢ã€‚
A very good way to do this is to use theÂ repository pattern, which lets you encapsulate all the data access logic (serialization, networking) inside a single class (the repository).
ä¸€å€‹éå¸¸å¥½çš„æ–¹æ³•æ˜¯ä½¿ç”¨å„²å­˜åº«æ¨¡å¼ (repository pattern)ï¼Œé€™ç¨®æ¨¡å¼è®“ä½ å¯ä»¥å°‡æ‰€æœ‰è³‡æ–™å­˜å–é‚è¼¯ï¼ˆå¦‚åºåˆ—åŒ–ã€ç¶²è·¯è«‹æ±‚ï¼‰å°è£åœ¨ä¸€å€‹é¡åˆ¥ï¼ˆå„²å­˜åº«ï¼‰ä¸­ã€‚
The benefit is that the rest of your app only communicates to theÂ public interfaceÂ of that repository and doesnâ€™t need to know about all its implementation details (such as what 3rd party APIs are used under the hood)."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Backups","item":"https://easylive1989.github.io/readings/backup/"},{"@type":"ListItem","position":2,"name":"How to Use Abstraction and the Repository Pattern Effectively in Your Flutter Apps","item":"https://easylive1989.github.io/readings/backup/how-to-use-abstraction-and-the-repository-pattern-effectively-in-your-flutter-apps/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"How to Use Abstraction and the Repository Pattern Effectively in Your Flutter Apps","name":"How to Use Abstraction and the Repository Pattern Effectively in Your Flutter Apps","description":"Source\nIf your Flutter app talks to a backend or some server-side APIs, youâ€™ll want to have a goodÂ separation of concernsÂ between the UI code and your data-access layer.\nå¦‚æœä½ çš„ Flutter æ‡‰ç”¨ç¨‹å¼éœ€è¦èˆ‡å¾Œç«¯æˆ–æŸäº›ä¼ºæœå™¨ç«¯ API é€šè¨Šï¼Œä½ æœƒå¸Œæœ›åœ¨ UI ä»£ç¢¼å’Œè³‡æ–™å­˜å–å±¤ä¹‹é–“æœ‰è‰¯å¥½çš„è²¬ä»»åˆ†é›¢ã€‚\nA very good way to do this is to use theÂ repository pattern, which lets you encapsulate all the data access logic (serialization, networking) inside a single class (the repository).\nä¸€å€‹éå¸¸å¥½çš„æ–¹æ³•æ˜¯ä½¿ç”¨å„²å­˜åº«æ¨¡å¼ (repository pattern)ï¼Œé€™ç¨®æ¨¡å¼è®“ä½ å¯ä»¥å°‡æ‰€æœ‰è³‡æ–™å­˜å–é‚è¼¯ï¼ˆå¦‚åºåˆ—åŒ–ã€ç¶²è·¯è«‹æ±‚ï¼‰å°è£åœ¨ä¸€å€‹é¡åˆ¥ï¼ˆå„²å­˜åº«ï¼‰ä¸­ã€‚\nThe benefit is that the rest of your app only communicates to theÂ public interfaceÂ of that repository and doesnâ€™t need to know about all its implementation details (such as what 3rd party APIs are used under the hood).\n","keywords":["Andrea Bizzotto"],"articleBody":"Source\nIf your Flutter app talks to a backend or some server-side APIs, youâ€™ll want to have a goodÂ separation of concernsÂ between the UI code and your data-access layer.\nå¦‚æœä½ çš„ Flutter æ‡‰ç”¨ç¨‹å¼éœ€è¦èˆ‡å¾Œç«¯æˆ–æŸäº›ä¼ºæœå™¨ç«¯ API é€šè¨Šï¼Œä½ æœƒå¸Œæœ›åœ¨ UI ä»£ç¢¼å’Œè³‡æ–™å­˜å–å±¤ä¹‹é–“æœ‰è‰¯å¥½çš„è²¬ä»»åˆ†é›¢ã€‚\nA very good way to do this is to use theÂ repository pattern, which lets you encapsulate all the data access logic (serialization, networking) inside a single class (the repository).\nä¸€å€‹éå¸¸å¥½çš„æ–¹æ³•æ˜¯ä½¿ç”¨å„²å­˜åº«æ¨¡å¼ (repository pattern)ï¼Œé€™ç¨®æ¨¡å¼è®“ä½ å¯ä»¥å°‡æ‰€æœ‰è³‡æ–™å­˜å–é‚è¼¯ï¼ˆå¦‚åºåˆ—åŒ–ã€ç¶²è·¯è«‹æ±‚ï¼‰å°è£åœ¨ä¸€å€‹é¡åˆ¥ï¼ˆå„²å­˜åº«ï¼‰ä¸­ã€‚\nThe benefit is that the rest of your app only communicates to theÂ public interfaceÂ of that repository and doesnâ€™t need to know about all its implementation details (such as what 3rd party APIs are used under the hood).\nå…¶å¥½è™•åœ¨æ–¼ï¼Œæ‡‰ç”¨ç¨‹å¼çš„å…¶ä»–éƒ¨åˆ†åªéœ€è¦èˆ‡å„²å­˜åº«çš„å…¬é–‹ä»‹é¢é€²è¡Œé€šè¨Šï¼Œç„¡éœ€äº†è§£å…¶æ‰€æœ‰å¯¦ä½œç´°ç¯€ï¼ˆä¾‹å¦‚åº•å±¤ä½¿ç”¨äº†å“ªäº›ç¬¬ä¸‰æ–¹ APIï¼‰ã€‚\nThe repository pattern has several advantages:\nå„²å­˜åº«æ¨¡å¼æœ‰ä»¥ä¸‹å¹¾å€‹å„ªé»ï¼š\nif the implementation changes but the interface stays the same, the rest of the app is unaffected\nyour code becomes more testable (you can mock the repository in your tests)\nyou can scale horizontally by creating multiple repositories if needed\nå¦‚æœå¯¦ä½œç™¼ç”Ÿè®ŠåŒ–ï¼Œä½†ä»‹é¢ä¿æŒä¸è®Šï¼Œæ‡‰ç”¨ç¨‹å¼çš„å…¶ä»–éƒ¨åˆ†ä¸æœƒå—åˆ°å½±éŸ¿ã€‚\nä½ çš„ä»£ç¢¼æ›´å®¹æ˜“é€²è¡Œæ¸¬è©¦ï¼ˆåœ¨æ¸¬è©¦ä¸­å¯ä»¥æ¨¡æ“¬å„²å­˜åº«ï¼‰ã€‚\nå¦‚æœéœ€è¦ï¼Œä½ å¯ä»¥é€šéå»ºç«‹å¤šå€‹å„²å­˜åº«ä¾†å¯¦ç¾æ°´å¹³æ“´å±•ã€‚\nAnd in this article, weâ€™ll go further and learn how to writeÂ backend-agnosticÂ code, by covering some usefulÂ abstractions.\nåœ¨æœ¬æ–‡ä¸­ï¼Œæˆ‘å€‘å°‡æ›´é€²ä¸€æ­¥ï¼Œå­¸ç¿’å¦‚ä½•æ’°å¯«èˆ‡å¾Œç«¯ç„¡é—œçš„ä»£ç¢¼ï¼Œä¸¦ä»‹ç´¹ä¸€äº›å¯¦ç”¨çš„æŠ½è±¡æ¦‚å¿µã€‚\nAbstraction lets you decouple the implementation details of a piece of code (usually a class or function) from the rest of the application. When used correctly, abstraction makes our code easier toÂ understand,Â maintain, andÂ test, and also allows developers to work independently on different parts of the codebase.\næŠ½è±¡å¯ä»¥è®“ä½ å°‡ä»£ç¢¼ï¼ˆé€šå¸¸æ˜¯ä¸€å€‹é¡åˆ¥æˆ–å‡½æ•¸ï¼‰çš„å¯¦ä½œç´°ç¯€èˆ‡æ‡‰ç”¨ç¨‹å¼çš„å…¶ä»–éƒ¨åˆ†åˆ†é›¢é–‹ä¾†ã€‚æ­£ç¢ºä½¿ç”¨æŠ½è±¡å¯ä»¥è®“ä»£ç¢¼æ›´å®¹æ˜“ç†è§£ã€ç¶­è­·å’Œæ¸¬è©¦ï¼Œä¸¦ä¸”å…è¨±é–‹ç™¼è€…åœ¨ä»£ç¢¼åº«çš„ä¸åŒéƒ¨åˆ†ç¨ç«‹å·¥ä½œã€‚\nAs part of this, weâ€™ll talk about â€œleakyâ€ abstractions, which happen when the public interface of the repository â€œleaksâ€ some implementation details that should remain hidden.\nä½œç‚ºå…¶ä¸­çš„ä¸€éƒ¨åˆ†ï¼Œæˆ‘å€‘æœƒè¨è«–ã€Œæ´©æ¼æ€§ã€æŠ½è±¡ï¼ˆleaky abstractionsï¼‰ï¼Œé€™ç¨®æƒ…æ³ç™¼ç”Ÿåœ¨å„²å­˜åº«çš„å…¬é–‹ä»‹é¢æ´©æ¼äº†ä¸€äº›æ‡‰è©²ä¿æŒéš±è—çš„å¯¦ä½œç´°ç¯€æ™‚ã€‚\nWeâ€™ll also talk about tradeoffs and learn that some kinds of abstractions are worthwhile while others arenâ€™t.\næˆ‘å€‘é‚„æœƒè¨è«–å–æ¨å•é¡Œï¼Œå­¸ç¿’å“ªäº›æŠ½è±¡æ˜¯å€¼å¾—çš„ï¼Œå“ªäº›å‰‡ä¸å€¼å¾—ã€‚\nIn covering all these concepts, Iâ€™ll show you some examples using the Firebase packages since they have a large API surface. But the same considerations apply if you use alternative backends (or, for that matter, any other local or remote storage packages your code depends on).\nåœ¨æ¶µè“‹é€™äº›æ¦‚å¿µæ™‚ï¼Œæˆ‘æœƒä½¿ç”¨ Firebase å¥—ä»¶èˆ‰ä¾‹ï¼Œå› ç‚ºå®ƒå€‘æ“æœ‰è±å¯Œçš„ APIã€‚å„˜ç®¡å¦‚æ­¤ï¼Œå¦‚æœä½ ä½¿ç”¨çš„æ˜¯å…¶ä»–å¾Œç«¯ï¼ˆæˆ–ä»»ä½•æœ¬åœ°æˆ–é ç«¯çš„å­˜å„²å¥—ä»¶ï¼‰ï¼Œé€™äº›è€ƒé‡åŒæ¨£é©ç”¨ã€‚\nBy the end, youâ€™ll know:\nåˆ°æœ¬æ–‡çµå°¾ï¼Œä½ å°‡å­¸åˆ°ï¼š\nhow to write repositories that are backend-agnostic (if you use a remote database)\nhow to spot â€œleakyâ€ abstractions in your code and how to fix them if desired\nwhich abstractions are good and make your code more testable, scalable, and maintainable\nwhich abstractions are overkill - or even counterproductive\nå¦‚ä½•æ’°å¯«èˆ‡å¾Œç«¯ç„¡é—œçš„å„²å­˜åº«ï¼ˆå¦‚æœä½ ä½¿ç”¨é ç«¯è³‡æ–™åº«ï¼‰ã€‚\nå¦‚ä½•ç™¼ç¾ä»£ç¢¼ä¸­çš„ã€Œæ´©æ¼æ€§ã€æŠ½è±¡ï¼Œä»¥åŠå¦‚ä½•ä¿®å¾©å®ƒå€‘ï¼ˆå¦‚æœéœ€è¦ï¼‰ã€‚\nå“ªäº›æŠ½è±¡æ˜¯å¥½çš„ï¼Œèƒ½è®“ä»£ç¢¼æ›´å®¹æ˜“æ¸¬è©¦ã€æ“´å±•å’Œç¶­è­·ã€‚\nå“ªäº›æŠ½è±¡æ˜¯éåº¦çš„ï¼Œç”šè‡³å¯èƒ½é©å¾—å…¶åã€‚\nReady? Letâ€™s go!\næº–å‚™å¥½äº†å—ï¼Ÿé–‹å§‹å§ï¼\nIf youâ€™re ever planning to migrate a live app to a different backend, there are many considerations to make, includingÂ data migration strategiesÂ and how toÂ keep downtime to a minimum. These are complex topics that are beyond the scope of this article. But writing a backend-agnostic codebase is a good first step that will make the rest of the process easier.\nå¦‚æœä½ è¨ˆåŠƒå°‡ä¸€å€‹ç·šä¸Šæ‡‰ç”¨ç¨‹å¼é·ç§»åˆ°ä¸åŒçš„å¾Œç«¯ï¼Œéœ€è¦è€ƒæ…®è¨±å¤šå› ç´ ï¼ŒåŒ…æ‹¬è³‡æ–™é·ç§»ç­–ç•¥ä»¥åŠå¦‚ä½•å°‡åœæ©Ÿæ™‚é–“é™è‡³æœ€ä½ã€‚é€™äº›æ˜¯è¶…å‡ºæœ¬æ–‡ç¯„åœçš„è¤‡é›œè©±é¡Œï¼Œä½†æ’°å¯«ä¸€å€‹èˆ‡å¾Œç«¯ç„¡é—œçš„ä»£ç¢¼åº«æ˜¯è®“æ•´å€‹éç¨‹æ›´è¼•é¬†çš„ç¬¬ä¸€æ­¥ã€‚\nHow to write backend-agnostic code: a practical example Suppose we want to read a collection of items from a remote database (such as Cloud Firestore) and show the result inside a list view.\nå‡è¨­æˆ‘å€‘å¸Œæœ›å¾é ç«¯è³‡æ–™åº«ï¼ˆä¾‹å¦‚ Cloud Firestoreï¼‰è®€å–ä¸€å€‹é …ç›®é›†åˆï¼Œä¸¦å°‡çµæœé¡¯ç¤ºåœ¨åˆ—è¡¨è¦–åœ–ä¸­ã€‚\nIf we use theÂ FirestoreListViewÂ widget from theÂ firebase_ui_firestoreÂ package, this can be easily accomplished by creating this simple widget:\nå¦‚æœæˆ‘å€‘ä½¿ç”¨ä¾†è‡ªÂ firebase_ui_firestoreÂ å¥—ä»¶çš„Â FirestoreListViewÂ å…ƒä»¶ï¼Œå¯ä»¥é€éä»¥ä¸‹ç°¡å–®çš„å…ƒä»¶è¼•é¬†å®Œæˆï¼š\nimport 'package:cloud_firestore/cloud_firestore.dart'; import 'package:firebase_ui_firestore/firebase_ui_firestore.dart'; // example code adapted from https://pub.dev/packages/firebase_ui_firestore class ItemsList extends StatelessWidget { const ItemsList({super.key}); @override Widget build(BuildContext context) { // get a query representing the data we want to get final itemsQuery = FirebaseFirestore.instance.collection('items').orderBy('name'); // use it to show all the items in the UI return FirestoreListView\u003cMap\u003cString, dynamic\u003e\u003e( query: itemsQuery, itemBuilder: (context, snapshot) { Map\u003cString, dynamic\u003e item = snapshot.data(); return Text('Item name is ${item['name']}'); }, ); } } The code above will work, but it clumps together two things that should be separate:\nä¸Šè¿°ä»£ç¢¼é›–ç„¶å¯ä»¥é‹è¡Œï¼Œä½†å®ƒå°‡å…©å€‹æ‡‰è©²åˆ†é›¢çš„éƒ¨åˆ†çµåˆåœ¨ä¸€èµ·ï¼š\ngetting the data from the remote backend\nshowing the data in the UI\nå¾é ç«¯å¾Œç«¯ç²å–è³‡æ–™\nåœ¨ UI ä¸­é¡¯ç¤ºè³‡æ–™\nThis has some drawbacks:\né€™æ¨£çš„åšæ³•å­˜åœ¨ä»¥ä¸‹ç¼ºé»ï¼š\nthe code is not testable (because we useÂ FirebaseFirestore.instanceÂ directly in the widget)\nthe UI code needs to know about Firestoreâ€™sÂ QueryDocumentSnapshotÂ API to extract the data\nthe UI code also needs to read key-value pairs inside the snapshotâ€™s data (Map)\nä»£ç¢¼ä¸å¯æ¸¬è©¦ï¼ˆå› ç‚ºæˆ‘å€‘ç›´æ¥åœ¨å…ƒä»¶ä¸­ä½¿ç”¨äº†Â FirebaseFirestore.instanceï¼‰ã€‚\nUI ä»£ç¢¼éœ€è¦çŸ¥é“ Firestore çš„Â QueryDocumentSnapshotÂ APIï¼Œæ‰èƒ½æå–è³‡æ–™ã€‚\nUI ä»£ç¢¼é‚„éœ€è¦å¾å¿«ç…§è³‡æ–™çš„ key-value å° (Map) ä¸­è®€å–å…§å®¹ã€‚\nIn other words, we have a poor separation of concerns because the UI code knows too many details about how to get the data and how it is structured.\næ›å¥è©±èªªï¼Œæˆ‘å€‘çš„è²¬ä»»åˆ†é›¢åšå¾—ä¸å¥½ï¼Œå› ç‚º UI ä»£ç¢¼çŸ¥é“å¤ªå¤šæœ‰é—œæ–¼å¦‚ä½•ç²å–è³‡æ–™åŠå…¶çµæ§‹çš„ç´°ç¯€ã€‚\nCan we do better?\næˆ‘å€‘å¯ä»¥æ”¹å–„å—ï¼Ÿ\nAdding a Data Layer Rather than keeping all the code inside theÂ ItemsListÂ widget, we can introduce a separate data layer:\nèˆ‡å…¶å°‡æ‰€æœ‰ä»£ç¢¼éƒ½æ”¾åœ¨Â ItemsListÂ å…ƒä»¶å…§ï¼Œä¸å¦‚å¼•å…¥ä¸€å€‹å–®ç¨çš„è³‡æ–™å±¤ï¼š\nThis data layer could contain anÂ ItemsRepositoryÂ that is defined as follows:\né€™å€‹è³‡æ–™å±¤å¯ä»¥åŒ…å«ä¸€å€‹Â ItemsRepositoryï¼Œå…¶å®šç¾©å¦‚ä¸‹ï¼š\nclass ItemsRepository { ItemsRepository(this._firestore); final FirebaseFirestore _firestore; Query\u003cItem\u003e itemsQuery() { return _firestore .collection('items') .withConverter( fromFirestore: (snapshot, _) =\u003e Item.fromMap(snapshot.data()!), toFirestore: (item, _) =\u003e item.toMap(), ) .orderBy('name'); } } We can create the corresponding provider as well (using Riverpod):\næˆ‘å€‘é‚„å¯ä»¥å‰µå»ºå°æ‡‰çš„æä¾›è€…ï¼ˆä½¿ç”¨ Riverpodï¼‰ï¼š\nfinal itemsRepositoryProvider = Provider\u003cItemsRepository\u003e((ref) { return ItemsRepository(FirebaseFirestore.instance); }); If youâ€™re not a Riverpod user, you could use a different dependency injection system likeÂ get_it, or evenÂ flutter_bloc. Read this for more details:Â Singletons in Flutter: How to Avoid Them and What to do Instead\nå¦‚æœä½ ä¸æ˜¯ Riverpod çš„ä½¿ç”¨è€…ï¼Œå¯ä»¥ä½¿ç”¨å…¶ä»–ä¾è³´æ³¨å…¥ç³»çµ±ï¼Œä¾‹å¦‚Â get_itï¼Œç”šè‡³æ˜¯Â flutter_blocã€‚æ›´å¤šç´°ç¯€è«‹åƒè€ƒï¼šSingletons in Flutter: How to Avoid Them and What to do Instead\nAnd we could also define a type-safeÂ ItemÂ class:\næˆ‘å€‘é‚„å¯ä»¥å®šç¾©ä¸€å€‹é¡å‹å®‰å…¨çš„Â ItemÂ é¡åˆ¥ï¼š\nclass Item { const Item({required this.name}); final String name; factory Item.fromMap(Map\u003cString, dynamic\u003e map) { return Item(name: map['name'] as String); } Map\u003cString, dynamic\u003e toMap() =\u003e {'name': name}; } Finally, we can update our widget code:\næœ€å¾Œï¼Œæˆ‘å€‘å¯ä»¥æ›´æ–°å…ƒä»¶ä»£ç¢¼ï¼š\nimport 'package:cloud_firestore/cloud_firestore.dart'; import 'package:firebase_ui_firestore/firebase_ui_firestore.dart'; class ItemsList extends ConsumerWidget { const ItemsList({super.key}); @override Widget build(BuildContext context, WidgetRef ref) { final itemsQuery = ref.watch(itemsRepositoryProvider).itemsQuery(); return FirestoreListView\u003cItem\u003e( query: itemsQuery, itemBuilder: (context, snapshot) { Item item = snapshot.data(); return Text('Item name is ${item.name}'); }, ); } } Clearly, we had to write more code to accomplish the same result (showing items inside a list).\né¡¯ç„¶ï¼Œç‚ºäº†å®ŒæˆåŒæ¨£çš„ç›®æ¨™ï¼ˆåœ¨åˆ—è¡¨ä¸­é¡¯ç¤ºé …ç›®ï¼‰ï¼Œæˆ‘å€‘å¿…é ˆæ’°å¯«æ›´å¤šä»£ç¢¼ã€‚\nBut this was not in vain because all the data-access implementation details are now encapsulated in theÂ ItemsRepository.\nä½†é€™ä¸¦éå¾’å‹ï¼Œå› ç‚ºç¾åœ¨æ‰€æœ‰çš„è³‡æ–™å­˜å–å¯¦ä½œç´°ç¯€éƒ½å°è£åœ¨Â ItemsRepositoryÂ ä¸­ã€‚\nAnd the UI code no longer needs to extract the item name from aÂ MapÂ (which is an implementation detail of the data-access layer). Instead, it can use theÂ ItemÂ model class thatÂ we have defined.\nä¸¦ä¸”ï¼ŒUI ä»£ç¢¼ä¸å†éœ€è¦å¾Â MapÂ ä¸­æå–é …ç›®åç¨±ï¼ˆé€™æ˜¯è³‡æ–™å­˜å–å±¤çš„å¯¦ä½œç´°ç¯€ï¼‰ã€‚ç›¸åï¼ŒUI å¯ä»¥ä½¿ç”¨æˆ‘å€‘è‡ªè¡Œå®šç¾©çš„Â ItemÂ æ¨¡å‹é¡åˆ¥ã€‚\nHowever, our UI code still needs to use the (Firestore-specific)Â QueryDocumentSnapshotÂ type when reading the data, and our widget class still depends onÂ cloud_firestore.dartÂ andÂ firebase_ui_firestore.dart.\nç„¶è€Œï¼ŒUI ä»£ç¢¼ä»ç„¶éœ€è¦ä½¿ç”¨ Firestore ç‰¹å®šçš„Â QueryDocumentSnapshotÂ é¡å‹ä¾†è®€å–è³‡æ–™ï¼Œè€Œæˆ‘å€‘çš„å…ƒä»¶é¡åˆ¥ä»ç„¶ä¾è³´æ–¼Â cloud_firestore.dartÂ å’ŒÂ firebase_ui_firestore.dartã€‚\nAnd this means that our UI code is stillÂ not backend-agnostic, and we would have to refactor it further if we wanted to move to a different backend in the future (e.g. Supabase).\né€™æ„å‘³è‘—ï¼Œæˆ‘å€‘çš„ UI ä»£ç¢¼ä»ç„¶ä¸æ˜¯èˆ‡å¾Œç«¯ç„¡é—œçš„ï¼Œå¦‚æœå°‡ä¾†æˆ‘å€‘æƒ³åˆ‡æ›åˆ°å…¶ä»–å¾Œç«¯ï¼ˆä¾‹å¦‚ Supabaseï¼‰ï¼Œä»éœ€é€²ä¸€æ­¥é‡æ§‹ã€‚\nLeaky Abstractions One thing we have overlooked is that the public interface of ourÂ ItemsRepositoryÂ contains a Firestore-specific type: theÂ QueryÂ class. ğŸ‘‡\næˆ‘å€‘å¿½ç•¥äº†ä¸€ä»¶äº‹ï¼Œå°±æ˜¯æˆ‘å€‘çš„Â ItemsRepositoryÂ çš„å…¬é–‹ä»‹é¢ä¸­åŒ…å«äº†ä¸€å€‹ Firestore ç‰¹å®šçš„é¡å‹ï¼šQueryã€‚ğŸ‘‡\nclass ItemsRepository { ItemsRepository(this._firestore); final FirebaseFirestore _firestore; // Query is defined inside cloud_firestore.dart Query\u003cItem\u003e itemsQuery() { ... } } I call this aÂ leaky abstractionÂ because our repository exposes a type that is defined inside theÂ cloud_firestoreÂ package, as can be seen in this diagram:\næˆ‘ç¨±é€™ç‚ºæ´©æ¼æ€§æŠ½è±¡ï¼Œå› ç‚ºæˆ‘å€‘çš„å„²å­˜åº«æš´éœ²äº†ä¸€å€‹åœ¨Â cloud_firestoreÂ å¥—ä»¶ä¸­å®šç¾©çš„é¡å‹ï¼Œå¦‚ä¸‹åœ–æ‰€ç¤ºï¼š\nAs a result, any code thatÂ consumesÂ theÂ itemsQuery()Â method will also depend onÂ cloud_firestore.dart:\nçµæœæ˜¯ï¼Œä»»ä½•ä½¿ç”¨ itemsQuery() æ–¹æ³•çš„ä»£ç¢¼éƒ½æœƒä¾è³´æ–¼ cloud_firestore.dartï¼š\n// [FirestoreListView] depends on cloud_firestore.dart FirestoreListView\u003cItem\u003e( query: ref.watch(itemsRepositoryProvider).itemsQuery(), itemBuilder: (context, snapshot) { Item item = snapshot.data(); return Text('Item name is ${item.name}'); }, ); But hang on!\nä½†ç­‰ç­‰ï¼\nIf we want to useÂ FirestoreListViewÂ in our code, we have no other choice but to give it aÂ QueryÂ argument. And inside theÂ itemBuilderÂ callback, we have to useÂ QueryDocumentSnapshotÂ (which is also Firebase-specific).\nå¦‚æœæˆ‘å€‘å¸Œæœ›åœ¨ä»£ç¢¼ä¸­ä½¿ç”¨ FirestoreListViewï¼Œåˆ¥ç„¡é¸æ“‡ï¼Œåªèƒ½ç‚ºå®ƒæä¾›ä¸€å€‹ Query åƒæ•¸ã€‚è€Œåœ¨ itemBuilder å›èª¿ä¸­ï¼Œæˆ‘å€‘å¿…é ˆä½¿ç”¨ QueryDocumentSnapshotï¼ˆé€™ä¹Ÿæ˜¯ Firebase ç‰¹æœ‰çš„ï¼‰ã€‚\nIndeed, the whole point of using theÂ firebase_ui_firestoreÂ package is that:\näº‹å¯¦ä¸Šï¼Œä½¿ç”¨ firebase_ui_firestore å¥—ä»¶çš„æ ¸å¿ƒç›®çš„åœ¨æ–¼ï¼š\nFirebase UI for Firestore enables you to easily integrate your application UI with your Cloud Firestore database.\nFirebase UI for Firestore è®“ä½ å¯ä»¥è¼•é¬†åœ°å°‡æ‡‰ç”¨ç¨‹å¼çš„ UI èˆ‡ Cloud Firestore è³‡æ–™åº«æ•´åˆã€‚\nSo, whether weâ€™ve done this intentionally or not,Â weâ€™ve made a tradeoff.\nå› æ­¤ï¼Œä¸ç®¡æˆ‘å€‘æ˜¯å¦æœ‰æ„è­˜åˆ°é€™é»ï¼Œæˆ‘å€‘åšäº†ä¸€å€‹å–æ¨ã€‚\nWeâ€™ve chosen to create a leaky abstraction (usingÂ QueryÂ in the public interface of our repository) in return for the ease of use of theÂ FirestoreListViewÂ widget.\næˆ‘å€‘é¸æ“‡å»ºç«‹ä¸€å€‹æ´©æ¼æ€§æŠ½è±¡ï¼ˆåœ¨å„²å­˜åº«çš„å…¬é–‹ä»‹é¢ä¸­ä½¿ç”¨ Queryï¼‰ï¼Œä»¥æ›å– FirestoreListView å…ƒä»¶çš„æ˜“ç”¨æ€§ã€‚\nBut this abstraction comes with someÂ tangible benefitsÂ because by usingÂ FirestoreListView,Â we get pagination for freeÂ and a convenient way toÂ handle loading and error states.\nä½†é€™å€‹æŠ½è±¡å¸¶ä¾†äº†ä¸€äº›å¯¦éš›çš„å¥½è™•ï¼Œå› ç‚ºä½¿ç”¨ FirestoreListViewï¼Œæˆ‘å€‘å¯ä»¥å…è²»ç²å¾—åˆ†é åŠŸèƒ½ï¼Œä»¥åŠä¸€ç¨®æ–¹ä¾¿çš„æ–¹å¼ä¾†è™•ç†åŠ è¼‰å’ŒéŒ¯èª¤ç‹€æ…‹ã€‚\nImplementing Firestore pagination manually can be a lot of work. So if thereâ€™s an official package that does a good job at it, weâ€™d be silly not to use it. ğŸ˜‰\næ‰‹å‹•å¯¦ç¾ Firestore çš„åˆ†é åŠŸèƒ½å¯èƒ½éœ€è¦å¤§é‡å·¥ä½œã€‚å› æ­¤ï¼Œå¦‚æœæœ‰ä¸€å€‹å®˜æ–¹å¥—ä»¶èƒ½å¾ˆå¥½åœ°è™•ç†é€™äº›å•é¡Œï¼Œæˆ‘å€‘ç•¶ç„¶æ‡‰è©²ç”¨å®ƒã€‚ğŸ˜‰\nRevisiting the Leaky Abstraction But letâ€™s suppose that weâ€™ve decided to move away from Cloud Firestore, and we want to make our code truly backend-agnostic.\nä½†å‡è¨­æˆ‘å€‘æ±ºå®šæ”¾æ£„ä½¿ç”¨ Cloud Firestoreï¼Œä¸¦å¸Œæœ›è®“ä»£ç¢¼çœŸæ­£åšåˆ°èˆ‡å¾Œç«¯ç„¡é—œã€‚\nHow can we do that?\næˆ‘å€‘è©²æ€éº¼åšï¼Ÿ\nWell, assuming we choose another remote database thatÂ supports realtime listeners, we can modify our repository to use aÂ StreamÂ and consume it in our widget using a regularÂ ListView, like this:\nå‡è¨­æˆ‘å€‘é¸æ“‡å¦ä¸€å€‹æ”¯æŒå¯¦æ™‚ç›£è½çš„é ç«¯è³‡æ–™åº«ï¼Œå¯ä»¥ä¿®æ”¹å„²å­˜åº«ä»¥ä½¿ç”¨ Streamï¼Œä¸¦åœ¨å…ƒä»¶ä¸­é€éæ™®é€šçš„ ListView ä½¿ç”¨å®ƒï¼Œä¾‹å¦‚ï¼š\nHereâ€™s what theÂ public interfaceÂ would look like:\nä»¥ä¸‹æ˜¯å…¬é–‹ä»‹é¢çš„æ¨£å­ï¼š\nclass ItemsRepository { Stream\u003cList\u003cItem\u003e\u003e itemsStream() { ... } } And hereâ€™s what the complete repository would look like:\nå®Œæ•´çš„å„²å­˜åº«ä»£ç¢¼å¦‚ä¸‹ï¼š\nclass ItemsRepository { ItemsRepository(this._firestore); final FirebaseFirestore _firestore; Stream\u003cList\u003cItem\u003e\u003e itemsStream() { return _firestore .collection('items') .withConverter( fromFirestore: (snapshot, _) =\u003e Item.fromMap(snapshot.data()!), toFirestore: (item, _) =\u003e item.toMap(), ) .orderBy('name') // needed to transform a Query to a Stream","wordCount":"4178","inLanguage":"en","datePublished":"2025-04-05T23:18:28+08:00","dateModified":"2025-04-05T23:18:28+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://easylive1989.github.io/readings/backup/how-to-use-abstraction-and-the-repository-pattern-effectively-in-your-flutter-apps/"},"publisher":{"@type":"Organization","name":"Readings","logo":{"@type":"ImageObject","url":"https://easylive1989.github.io/readings/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://easylive1989.github.io/readings/ accesskey=h title="Readings (Alt + H)">Readings</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://easylive1989.github.io/readings/backup/ title=Backups><span>Backups</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">How to Use Abstraction and the Repository Pattern Effectively in Your Flutter Apps</h1><div class=post-meta><span title='2025-04-05 23:18:28 +0800 +0800'>April 5, 2025</span></div></header><div class=post-content><p><a href="https://codewithandrea.com/articles/abstraction-repository-pattern-flutter/?utm_source=canopas-stack-weekly">Source</a></p><p>If your Flutter app talks to a backend or some server-side APIs, youâ€™ll want to have a goodÂ <strong>separation of concerns</strong>Â between the UI code and your data-access layer.</p><p>å¦‚æœä½ çš„ Flutter æ‡‰ç”¨ç¨‹å¼éœ€è¦èˆ‡å¾Œç«¯æˆ–æŸäº›ä¼ºæœå™¨ç«¯ API é€šè¨Šï¼Œä½ æœƒå¸Œæœ›åœ¨ UI ä»£ç¢¼å’Œè³‡æ–™å­˜å–å±¤ä¹‹é–“æœ‰è‰¯å¥½çš„<strong>è²¬ä»»åˆ†é›¢</strong>ã€‚</p><p>A very good way to do this is to use theÂ <a href=https://codewithandrea.com/articles/flutter-repository-pattern/>repository pattern</a>, which lets you encapsulate all the data access logic (serialization, networking) inside a single class (the repository).</p><p>ä¸€å€‹éå¸¸å¥½çš„æ–¹æ³•æ˜¯ä½¿ç”¨<a href=https://codewithandrea.com/articles/flutter-repository-pattern/>å„²å­˜åº«æ¨¡å¼ (repository pattern)</a>ï¼Œé€™ç¨®æ¨¡å¼è®“ä½ å¯ä»¥å°‡æ‰€æœ‰è³‡æ–™å­˜å–é‚è¼¯ï¼ˆå¦‚åºåˆ—åŒ–ã€ç¶²è·¯è«‹æ±‚ï¼‰å°è£åœ¨ä¸€å€‹é¡åˆ¥ï¼ˆå„²å­˜åº«ï¼‰ä¸­ã€‚</p><p>The benefit is that the rest of your app only communicates to theÂ <strong>public interface</strong>Â of that repository and doesnâ€™t need to know about all its implementation details (such as what 3rd party APIs are used under the hood).</p><p>å…¶å¥½è™•åœ¨æ–¼ï¼Œæ‡‰ç”¨ç¨‹å¼çš„å…¶ä»–éƒ¨åˆ†åªéœ€è¦èˆ‡å„²å­˜åº«çš„<strong>å…¬é–‹ä»‹é¢</strong>é€²è¡Œé€šè¨Šï¼Œç„¡éœ€äº†è§£å…¶æ‰€æœ‰å¯¦ä½œç´°ç¯€ï¼ˆä¾‹å¦‚åº•å±¤ä½¿ç”¨äº†å“ªäº›ç¬¬ä¸‰æ–¹ APIï¼‰ã€‚</p><p>The repository pattern has several advantages:</p><p>å„²å­˜åº«æ¨¡å¼æœ‰ä»¥ä¸‹å¹¾å€‹å„ªé»ï¼š</p><ul><li><p>if the implementation changes but the interface stays the same, the rest of the app is unaffected</p></li><li><p>your code becomes more testable (you can mock the repository in your tests)</p></li><li><p>you can scale horizontally by creating multiple repositories if needed</p></li><li><p>å¦‚æœå¯¦ä½œç™¼ç”Ÿè®ŠåŒ–ï¼Œä½†ä»‹é¢ä¿æŒä¸è®Šï¼Œæ‡‰ç”¨ç¨‹å¼çš„å…¶ä»–éƒ¨åˆ†ä¸æœƒå—åˆ°å½±éŸ¿ã€‚</p></li><li><p>ä½ çš„ä»£ç¢¼æ›´å®¹æ˜“é€²è¡Œæ¸¬è©¦ï¼ˆåœ¨æ¸¬è©¦ä¸­å¯ä»¥æ¨¡æ“¬å„²å­˜åº«ï¼‰ã€‚</p></li><li><p>å¦‚æœéœ€è¦ï¼Œä½ å¯ä»¥é€šéå»ºç«‹å¤šå€‹å„²å­˜åº«ä¾†å¯¦ç¾æ°´å¹³æ“´å±•ã€‚</p></li></ul><p>And in this article, weâ€™ll go further and learn how to writeÂ <strong>backend-agnostic</strong>Â code, by covering some usefulÂ <strong>abstractions</strong>.</p><p>åœ¨æœ¬æ–‡ä¸­ï¼Œæˆ‘å€‘å°‡æ›´é€²ä¸€æ­¥ï¼Œå­¸ç¿’å¦‚ä½•æ’°å¯«<strong>èˆ‡å¾Œç«¯ç„¡é—œ</strong>çš„ä»£ç¢¼ï¼Œä¸¦ä»‹ç´¹ä¸€äº›å¯¦ç”¨çš„<strong>æŠ½è±¡æ¦‚å¿µ</strong>ã€‚</p><blockquote><p>Abstraction lets you decouple the implementation details of a piece of code (usually a class or function) from the rest of the application. When used correctly, abstraction makes our code easier toÂ <strong>understand</strong>,Â <strong>maintain</strong>, andÂ <strong>test</strong>, and also allows developers to work independently on different parts of the codebase.</p><p>æŠ½è±¡å¯ä»¥è®“ä½ å°‡ä»£ç¢¼ï¼ˆé€šå¸¸æ˜¯ä¸€å€‹é¡åˆ¥æˆ–å‡½æ•¸ï¼‰çš„å¯¦ä½œç´°ç¯€èˆ‡æ‡‰ç”¨ç¨‹å¼çš„å…¶ä»–éƒ¨åˆ†åˆ†é›¢é–‹ä¾†ã€‚æ­£ç¢ºä½¿ç”¨æŠ½è±¡å¯ä»¥è®“ä»£ç¢¼æ›´å®¹æ˜“<strong>ç†è§£</strong>ã€<strong>ç¶­è­·</strong>å’Œ<strong>æ¸¬è©¦</strong>ï¼Œä¸¦ä¸”å…è¨±é–‹ç™¼è€…åœ¨ä»£ç¢¼åº«çš„ä¸åŒéƒ¨åˆ†ç¨ç«‹å·¥ä½œã€‚</p></blockquote><p>As part of this, weâ€™ll talk about â€œleakyâ€ abstractions, which happen when the public interface of the repository â€œleaksâ€ some implementation details that should remain hidden.</p><p>ä½œç‚ºå…¶ä¸­çš„ä¸€éƒ¨åˆ†ï¼Œæˆ‘å€‘æœƒè¨è«–ã€Œæ´©æ¼æ€§ã€æŠ½è±¡ï¼ˆleaky abstractionsï¼‰ï¼Œé€™ç¨®æƒ…æ³ç™¼ç”Ÿåœ¨å„²å­˜åº«çš„å…¬é–‹ä»‹é¢æ´©æ¼äº†ä¸€äº›æ‡‰è©²ä¿æŒéš±è—çš„å¯¦ä½œç´°ç¯€æ™‚ã€‚</p><p>Weâ€™ll also talk about tradeoffs and learn that some kinds of abstractions are worthwhile while others arenâ€™t.</p><p>æˆ‘å€‘é‚„æœƒè¨è«–å–æ¨å•é¡Œï¼Œå­¸ç¿’å“ªäº›æŠ½è±¡æ˜¯å€¼å¾—çš„ï¼Œå“ªäº›å‰‡ä¸å€¼å¾—ã€‚</p><p>In covering all these concepts, Iâ€™ll show you some examples using the Firebase packages since they have a large API surface. But the same considerations apply if you use alternative backends (or, for that matter, any other local or remote storage packages your code depends on).</p><p>åœ¨æ¶µè“‹é€™äº›æ¦‚å¿µæ™‚ï¼Œæˆ‘æœƒä½¿ç”¨ Firebase å¥—ä»¶èˆ‰ä¾‹ï¼Œå› ç‚ºå®ƒå€‘æ“æœ‰è±å¯Œçš„ APIã€‚å„˜ç®¡å¦‚æ­¤ï¼Œå¦‚æœä½ ä½¿ç”¨çš„æ˜¯å…¶ä»–å¾Œç«¯ï¼ˆæˆ–ä»»ä½•æœ¬åœ°æˆ–é ç«¯çš„å­˜å„²å¥—ä»¶ï¼‰ï¼Œé€™äº›è€ƒé‡åŒæ¨£é©ç”¨ã€‚</p><p>By the end, youâ€™ll know:</p><p>åˆ°æœ¬æ–‡çµå°¾ï¼Œä½ å°‡å­¸åˆ°ï¼š</p><ul><li><p>how to write repositories that are backend-agnostic (if you use a remote database)</p></li><li><p>how to spot â€œleakyâ€ abstractions in your code and how to fix them if desired</p></li><li><p>which abstractions are good and make your code more testable, scalable, and maintainable</p></li><li><p>which abstractions are overkill - or even counterproductive</p></li><li><p>å¦‚ä½•æ’°å¯«èˆ‡å¾Œç«¯ç„¡é—œçš„å„²å­˜åº«ï¼ˆå¦‚æœä½ ä½¿ç”¨é ç«¯è³‡æ–™åº«ï¼‰ã€‚</p></li><li><p>å¦‚ä½•ç™¼ç¾ä»£ç¢¼ä¸­çš„ã€Œæ´©æ¼æ€§ã€æŠ½è±¡ï¼Œä»¥åŠå¦‚ä½•ä¿®å¾©å®ƒå€‘ï¼ˆå¦‚æœéœ€è¦ï¼‰ã€‚</p></li><li><p>å“ªäº›æŠ½è±¡æ˜¯å¥½çš„ï¼Œèƒ½è®“ä»£ç¢¼æ›´å®¹æ˜“æ¸¬è©¦ã€æ“´å±•å’Œç¶­è­·ã€‚</p></li><li><p>å“ªäº›æŠ½è±¡æ˜¯éåº¦çš„ï¼Œç”šè‡³å¯èƒ½é©å¾—å…¶åã€‚</p></li></ul><p>Ready? Letâ€™s go!</p><p>æº–å‚™å¥½äº†å—ï¼Ÿé–‹å§‹å§ï¼</p><blockquote><p>If youâ€™re ever planning to migrate a live app to a different backend, there are many considerations to make, includingÂ <strong>data migration strategies</strong>Â and how toÂ <strong>keep downtime to a minimum</strong>. These are complex topics that are beyond the scope of this article. But writing a backend-agnostic codebase is a good first step that will make the rest of the process easier.</p><p>å¦‚æœä½ è¨ˆåŠƒå°‡ä¸€å€‹ç·šä¸Šæ‡‰ç”¨ç¨‹å¼é·ç§»åˆ°ä¸åŒçš„å¾Œç«¯ï¼Œéœ€è¦è€ƒæ…®è¨±å¤šå› ç´ ï¼ŒåŒ…æ‹¬<strong>è³‡æ–™é·ç§»ç­–ç•¥</strong>ä»¥åŠå¦‚ä½•<strong>å°‡åœæ©Ÿæ™‚é–“é™è‡³æœ€ä½</strong>ã€‚é€™äº›æ˜¯è¶…å‡ºæœ¬æ–‡ç¯„åœçš„è¤‡é›œè©±é¡Œï¼Œä½†æ’°å¯«ä¸€å€‹èˆ‡å¾Œç«¯ç„¡é—œçš„ä»£ç¢¼åº«æ˜¯è®“æ•´å€‹éç¨‹æ›´è¼•é¬†çš„ç¬¬ä¸€æ­¥ã€‚</p></blockquote><h2 id=how-to-write-backend-agnostic-code-a-practical-example>How to write backend-agnostic code: a practical example<a hidden class=anchor aria-hidden=true href=#how-to-write-backend-agnostic-code-a-practical-example>#</a></h2><p>Suppose we want to read a collection of items from a remote database (such as Cloud Firestore) and show the result inside a list view.</p><p>å‡è¨­æˆ‘å€‘å¸Œæœ›å¾é ç«¯è³‡æ–™åº«ï¼ˆä¾‹å¦‚ Cloud Firestoreï¼‰è®€å–ä¸€å€‹é …ç›®é›†åˆï¼Œä¸¦å°‡çµæœé¡¯ç¤ºåœ¨åˆ—è¡¨è¦–åœ–ä¸­ã€‚</p><p>If we use theÂ <a href=https://pub.dev/documentation/firebase_ui_firestore/latest/firebase_ui_firestore/FirestoreListView-class.html>FirestoreListView</a>Â widget from theÂ <a href=https://pub.dev/packages/firebase_ui_firestore>firebase_ui_firestore</a>Â package, this can be easily accomplished by creating this simple widget:</p><p>å¦‚æœæˆ‘å€‘ä½¿ç”¨ä¾†è‡ªÂ <a href=https://pub.dev/packages/firebase_ui_firestore>firebase_ui_firestore</a>Â å¥—ä»¶çš„Â <a href=https://pub.dev/documentation/firebase_ui_firestore/latest/firebase_ui_firestore/FirestoreListView-class.html>FirestoreListView</a>Â å…ƒä»¶ï¼Œå¯ä»¥é€éä»¥ä¸‹ç°¡å–®çš„å…ƒä»¶è¼•é¬†å®Œæˆï¼š</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dart data-lang=dart><span style=display:flex><span><span style=color:#66d9ef>import</span> <span style=color:#e6db74>&#39;package:cloud_firestore/cloud_firestore.dart&#39;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> <span style=color:#e6db74>&#39;package:firebase_ui_firestore/firebase_ui_firestore.dart&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// example code adapted from https://pub.dev/packages/firebase_ui_firestore
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ItemsList</span> <span style=color:#66d9ef>extends</span> StatelessWidget {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> ItemsList({<span style=color:#66d9ef>super</span>.key});
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#960050;background-color:#1e0010>@</span>override
</span></span><span style=display:flex><span>  Widget build(BuildContext context) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// get a query representing the data we want to get
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>final</span> itemsQuery <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>        FirebaseFirestore.instance.collection(<span style=color:#e6db74>&#39;items&#39;</span>).orderBy(<span style=color:#e6db74>&#39;name&#39;</span>);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// use it to show all the items in the UI
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> FirestoreListView<span style=color:#f92672>&lt;</span>Map<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>String</span>, <span style=color:#66d9ef>dynamic</span><span style=color:#f92672>&gt;&gt;</span>(
</span></span><span style=display:flex><span>      query: itemsQuery,
</span></span><span style=display:flex><span>      itemBuilder: (context, snapshot) {
</span></span><span style=display:flex><span>        Map<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>String</span>, <span style=color:#66d9ef>dynamic</span><span style=color:#f92672>&gt;</span> item <span style=color:#f92672>=</span> snapshot.data();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> Text(<span style=color:#e6db74>&#39;Item name is </span><span style=color:#e6db74>${</span>item[<span style=color:#e6db74>&#39;name&#39;</span>]<span style=color:#e6db74>}</span><span style=color:#e6db74>&#39;</span>);
</span></span><span style=display:flex><span>      },
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The code above will work, but it clumps together two things that should be separate:</p><p>ä¸Šè¿°ä»£ç¢¼é›–ç„¶å¯ä»¥é‹è¡Œï¼Œä½†å®ƒå°‡å…©å€‹æ‡‰è©²åˆ†é›¢çš„éƒ¨åˆ†çµåˆåœ¨ä¸€èµ·ï¼š</p><ul><li><p>getting the data from the remote backend</p></li><li><p>showing the data in the UI</p></li><li><p>å¾é ç«¯å¾Œç«¯ç²å–è³‡æ–™</p></li><li><p>åœ¨ UI ä¸­é¡¯ç¤ºè³‡æ–™</p></li></ul><p>This has some drawbacks:</p><p>é€™æ¨£çš„åšæ³•å­˜åœ¨ä»¥ä¸‹ç¼ºé»ï¼š</p><ul><li><p>the code is not testable (because we useÂ <code>FirebaseFirestore.instance</code>Â directly in the widget)</p></li><li><p>the UI code needs to know about Firestoreâ€™sÂ <code>QueryDocumentSnapshot</code>Â API to extract the data</p></li><li><p>the UI code also needs to read key-value pairs inside the snapshotâ€™s data (<code>Map&lt;String, dynamic></code>)</p></li><li><p>ä»£ç¢¼ä¸å¯æ¸¬è©¦ï¼ˆå› ç‚ºæˆ‘å€‘ç›´æ¥åœ¨å…ƒä»¶ä¸­ä½¿ç”¨äº†Â <code>FirebaseFirestore.instance</code>ï¼‰ã€‚</p></li><li><p>UI ä»£ç¢¼éœ€è¦çŸ¥é“ Firestore çš„Â <code>QueryDocumentSnapshot</code>Â APIï¼Œæ‰èƒ½æå–è³‡æ–™ã€‚</p></li><li><p>UI ä»£ç¢¼é‚„éœ€è¦å¾å¿«ç…§è³‡æ–™çš„ key-value å° (<code>Map&lt;String, dynamic></code>) ä¸­è®€å–å…§å®¹ã€‚</p></li></ul><p>In other words, we have a poor separation of concerns because the UI code knows too many details about how to get the data and how it is structured.</p><p>æ›å¥è©±èªªï¼Œæˆ‘å€‘çš„è²¬ä»»åˆ†é›¢åšå¾—ä¸å¥½ï¼Œå› ç‚º UI ä»£ç¢¼çŸ¥é“å¤ªå¤šæœ‰é—œæ–¼å¦‚ä½•ç²å–è³‡æ–™åŠå…¶çµæ§‹çš„ç´°ç¯€ã€‚</p><p>Can we do better?</p><p>æˆ‘å€‘å¯ä»¥æ”¹å–„å—ï¼Ÿ</p><h3 id=adding-a-data-layer>Adding a Data Layer<a hidden class=anchor aria-hidden=true href=#adding-a-data-layer>#</a></h3><p>Rather than keeping all the code inside theÂ <code>ItemsList</code>Â widget, we can introduce a separate data layer:</p><p>èˆ‡å…¶å°‡æ‰€æœ‰ä»£ç¢¼éƒ½æ”¾åœ¨Â <code>ItemsList</code>Â å…ƒä»¶å…§ï¼Œä¸å¦‚å¼•å…¥ä¸€å€‹å–®ç¨çš„è³‡æ–™å±¤ï¼š</p><p><img alt="Separation of concerns between the presentation and data layers" loading=lazy src=https://codewithandrea.com/articles/abstraction-repository-pattern-flutter/images/presentation-data-layer.webp></p><p>This data layer could contain anÂ <code>ItemsRepository</code>Â that is defined as follows:</p><p>é€™å€‹è³‡æ–™å±¤å¯ä»¥åŒ…å«ä¸€å€‹Â <code>ItemsRepository</code>ï¼Œå…¶å®šç¾©å¦‚ä¸‹ï¼š</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dart data-lang=dart><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ItemsRepository</span> {
</span></span><span style=display:flex><span>  ItemsRepository(<span style=color:#66d9ef>this</span>._firestore);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>final</span> FirebaseFirestore _firestore;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  Query<span style=color:#f92672>&lt;</span>Item<span style=color:#f92672>&gt;</span> itemsQuery() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> _firestore
</span></span><span style=display:flex><span>        .collection(<span style=color:#e6db74>&#39;items&#39;</span>)
</span></span><span style=display:flex><span>        .withConverter(
</span></span><span style=display:flex><span>          fromFirestore: (snapshot, _) <span style=color:#f92672>=&gt;</span> Item.fromMap(snapshot.data()<span style=color:#f92672>!</span>),
</span></span><span style=display:flex><span>          toFirestore: (item, _) <span style=color:#f92672>=&gt;</span> item.toMap(),
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>        .orderBy(<span style=color:#e6db74>&#39;name&#39;</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We can create the corresponding provider as well (using Riverpod):</p><p>æˆ‘å€‘é‚„å¯ä»¥å‰µå»ºå°æ‡‰çš„æä¾›è€…ï¼ˆä½¿ç”¨ Riverpodï¼‰ï¼š</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dart data-lang=dart><span style=display:flex><span><span style=color:#66d9ef>final</span> itemsRepositoryProvider <span style=color:#f92672>=</span> Provider<span style=color:#f92672>&lt;</span>ItemsRepository<span style=color:#f92672>&gt;</span>((ref) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> ItemsRepository(FirebaseFirestore.instance);
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><blockquote><p>If you&rsquo;re not a Riverpod user, you could use a different dependency injection system likeÂ <a href=https://pub.dev/packages/get_it>get_it</a>, or evenÂ <a href=https://pub.dev/packages/flutter_bloc>flutter_bloc</a>. Read this for more details:Â <a href=https://codewithandrea.com/articles/flutter-singletons/>Singletons in Flutter: How to Avoid Them and What to do Instead</a></p><p>å¦‚æœä½ ä¸æ˜¯ Riverpod çš„ä½¿ç”¨è€…ï¼Œå¯ä»¥ä½¿ç”¨å…¶ä»–ä¾è³´æ³¨å…¥ç³»çµ±ï¼Œä¾‹å¦‚Â <a href=https://pub.dev/packages/get_it>get_it</a>ï¼Œç”šè‡³æ˜¯Â <a href=https://pub.dev/packages/flutter_bloc>flutter_bloc</a>ã€‚æ›´å¤šç´°ç¯€è«‹åƒè€ƒï¼š<a href=https://codewithandrea.com/articles/flutter-singletons/>Singletons in Flutter: How to Avoid Them and What to do Instead</a></p></blockquote><p>And we could also define a type-safeÂ <code>Item</code>Â class:</p><p>æˆ‘å€‘é‚„å¯ä»¥å®šç¾©ä¸€å€‹é¡å‹å®‰å…¨çš„Â <code>Item</code>Â é¡åˆ¥ï¼š</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dart data-lang=dart><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Item</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> Item({<span style=color:#66d9ef>required</span> <span style=color:#66d9ef>this</span>.name});
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>String</span> name;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>factory</span> Item.fromMap(Map<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>String</span>, <span style=color:#66d9ef>dynamic</span><span style=color:#f92672>&gt;</span> map) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> Item(name: map[<span style=color:#e6db74>&#39;name&#39;</span>] <span style=color:#f92672>as</span> <span style=color:#66d9ef>String</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  Map<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>String</span>, <span style=color:#66d9ef>dynamic</span><span style=color:#f92672>&gt;</span> toMap() <span style=color:#f92672>=&gt;</span> {<span style=color:#e6db74>&#39;name&#39;</span><span style=color:#f92672>:</span> name};
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Finally, we can update our widget code:</p><p>æœ€å¾Œï¼Œæˆ‘å€‘å¯ä»¥æ›´æ–°å…ƒä»¶ä»£ç¢¼ï¼š</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dart data-lang=dart><span style=display:flex><span><span style=color:#66d9ef>import</span> <span style=color:#e6db74>&#39;package:cloud_firestore/cloud_firestore.dart&#39;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> <span style=color:#e6db74>&#39;package:firebase_ui_firestore/firebase_ui_firestore.dart&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ItemsList</span> <span style=color:#66d9ef>extends</span> ConsumerWidget {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> ItemsList({<span style=color:#66d9ef>super</span>.key});
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#960050;background-color:#1e0010>@</span>override
</span></span><span style=display:flex><span>  Widget build(BuildContext context, WidgetRef ref) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>final</span> itemsQuery <span style=color:#f92672>=</span> ref.watch(itemsRepositoryProvider).itemsQuery();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> FirestoreListView<span style=color:#f92672>&lt;</span>Item<span style=color:#f92672>&gt;</span>(
</span></span><span style=display:flex><span>      query: itemsQuery,
</span></span><span style=display:flex><span>      itemBuilder: (context, snapshot) {
</span></span><span style=display:flex><span>        Item item <span style=color:#f92672>=</span> snapshot.data();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> Text(<span style=color:#e6db74>&#39;Item name is </span><span style=color:#e6db74>${</span>item.name<span style=color:#e6db74>}</span><span style=color:#e6db74>&#39;</span>);
</span></span><span style=display:flex><span>      },
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Clearly, we had to write more code to accomplish the same result (showing items inside a list).</p><p>é¡¯ç„¶ï¼Œç‚ºäº†å®ŒæˆåŒæ¨£çš„ç›®æ¨™ï¼ˆåœ¨åˆ—è¡¨ä¸­é¡¯ç¤ºé …ç›®ï¼‰ï¼Œæˆ‘å€‘å¿…é ˆæ’°å¯«æ›´å¤šä»£ç¢¼ã€‚</p><p>But this was not in vain because all the data-access implementation details are now encapsulated in theÂ <code>ItemsRepository</code>.</p><p>ä½†é€™ä¸¦éå¾’å‹ï¼Œå› ç‚ºç¾åœ¨æ‰€æœ‰çš„è³‡æ–™å­˜å–å¯¦ä½œç´°ç¯€éƒ½å°è£åœ¨Â <code>ItemsRepository</code>Â ä¸­ã€‚</p><p>And the UI code no longer needs to extract the item name from aÂ <code>Map&lt;String, dynamic></code>Â (which is an implementation detail of the data-access layer). Instead, it can use theÂ <code>Item</code>Â model class thatÂ <strong>we have defined</strong>.</p><p>ä¸¦ä¸”ï¼ŒUI ä»£ç¢¼ä¸å†éœ€è¦å¾Â <code>Map&lt;String, dynamic></code>Â ä¸­æå–é …ç›®åç¨±ï¼ˆé€™æ˜¯è³‡æ–™å­˜å–å±¤çš„å¯¦ä½œç´°ç¯€ï¼‰ã€‚ç›¸åï¼ŒUI å¯ä»¥ä½¿ç”¨æˆ‘å€‘<strong>è‡ªè¡Œå®šç¾©</strong>çš„Â <code>Item</code>Â æ¨¡å‹é¡åˆ¥ã€‚</p><p>However, our UI code still needs to use the (Firestore-specific)Â <code>QueryDocumentSnapshot</code>Â type when reading the data, and our widget class still depends onÂ <code>cloud_firestore.dart</code>Â andÂ <code>firebase_ui_firestore.dart</code>.</p><p>ç„¶è€Œï¼ŒUI ä»£ç¢¼ä»ç„¶éœ€è¦ä½¿ç”¨ Firestore ç‰¹å®šçš„Â <code>QueryDocumentSnapshot</code>Â é¡å‹ä¾†è®€å–è³‡æ–™ï¼Œè€Œæˆ‘å€‘çš„å…ƒä»¶é¡åˆ¥ä»ç„¶ä¾è³´æ–¼Â <code>cloud_firestore.dart</code>Â å’ŒÂ <code>firebase_ui_firestore.dart</code>ã€‚</p><p>And this means that our UI code is stillÂ <strong>not backend-agnostic</strong>, and we would have to refactor it further if we wanted to move to a different backend in the future (e.g. Supabase).</p><p>é€™æ„å‘³è‘—ï¼Œæˆ‘å€‘çš„ UI ä»£ç¢¼ä»ç„¶<strong>ä¸æ˜¯èˆ‡å¾Œç«¯ç„¡é—œçš„</strong>ï¼Œå¦‚æœå°‡ä¾†æˆ‘å€‘æƒ³åˆ‡æ›åˆ°å…¶ä»–å¾Œç«¯ï¼ˆä¾‹å¦‚ Supabaseï¼‰ï¼Œä»éœ€é€²ä¸€æ­¥é‡æ§‹ã€‚</p><h3 id=leaky-abstractions>Leaky Abstractions<a hidden class=anchor aria-hidden=true href=#leaky-abstractions>#</a></h3><p>One thing we have overlooked is that the public interface of ourÂ <code>ItemsRepository</code>Â contains a Firestore-specific type: theÂ <code>Query</code>Â class. ğŸ‘‡</p><p>æˆ‘å€‘å¿½ç•¥äº†ä¸€ä»¶äº‹ï¼Œå°±æ˜¯æˆ‘å€‘çš„Â <code>ItemsRepository</code>Â çš„å…¬é–‹ä»‹é¢ä¸­åŒ…å«äº†ä¸€å€‹ Firestore ç‰¹å®šçš„é¡å‹ï¼š<code>Query</code>ã€‚ğŸ‘‡</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dart data-lang=dart><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ItemsRepository</span> {
</span></span><span style=display:flex><span>  ItemsRepository(<span style=color:#66d9ef>this</span>._firestore);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>final</span> FirebaseFirestore _firestore;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Query is defined inside cloud_firestore.dart
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  Query<span style=color:#f92672>&lt;</span>Item<span style=color:#f92672>&gt;</span> itemsQuery() { ... }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>I call this aÂ <strong>leaky abstraction</strong>Â because our repository exposes a type that is defined inside theÂ <a href=https://pub.dev/packages/cloud_firestore>cloud_firestore</a>Â package, as can be seen in this diagram:</p><p>æˆ‘ç¨±é€™ç‚º<strong>æ´©æ¼æ€§æŠ½è±¡</strong>ï¼Œå› ç‚ºæˆ‘å€‘çš„å„²å­˜åº«æš´éœ²äº†ä¸€å€‹åœ¨Â <a href=https://pub.dev/packages/cloud_firestore>cloud_firestore</a>Â å¥—ä»¶ä¸­å®šç¾©çš„é¡å‹ï¼Œå¦‚ä¸‹åœ–æ‰€ç¤ºï¼š</p><p><img alt="Can you spot the &ldquo;leaky&rdquo; abstraction?" loading=lazy src=https://codewithandrea.com/articles/abstraction-repository-pattern-flutter/images/presentation-data-layer-query.webp></p><p>As a result, any code thatÂ <strong>consumes</strong>Â theÂ <code>itemsQuery()</code>Â method will also depend onÂ <code>cloud_firestore.dart</code>:</p><p>çµæœæ˜¯ï¼Œä»»ä½•ä½¿ç”¨ <code>itemsQuery()</code> æ–¹æ³•çš„ä»£ç¢¼éƒ½æœƒä¾è³´æ–¼ <code>cloud_firestore.dart</code>ï¼š</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dart data-lang=dart><span style=display:flex><span><span style=color:#75715e>// [FirestoreListView] depends on cloud_firestore.dart
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>FirestoreListView<span style=color:#f92672>&lt;</span>Item<span style=color:#f92672>&gt;</span>(
</span></span><span style=display:flex><span>  query: ref.watch(itemsRepositoryProvider).itemsQuery(),
</span></span><span style=display:flex><span>  itemBuilder: (context, snapshot) {
</span></span><span style=display:flex><span>    Item item <span style=color:#f92672>=</span> snapshot.data();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> Text(<span style=color:#e6db74>&#39;Item name is </span><span style=color:#e6db74>${</span>item.name<span style=color:#e6db74>}</span><span style=color:#e6db74>&#39;</span>);
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>);
</span></span></code></pre></div><p>But hang on!</p><p>ä½†ç­‰ç­‰ï¼</p><p>If we want to useÂ <code>FirestoreListView</code>Â in our code, we have no other choice but to give it aÂ <code>Query</code>Â argument. And inside theÂ <code>itemBuilder</code>Â callback, we have to useÂ <code>QueryDocumentSnapshot</code>Â (which is also Firebase-specific).</p><p>å¦‚æœæˆ‘å€‘å¸Œæœ›åœ¨ä»£ç¢¼ä¸­ä½¿ç”¨ <code>FirestoreListView</code>ï¼Œåˆ¥ç„¡é¸æ“‡ï¼Œåªèƒ½ç‚ºå®ƒæä¾›ä¸€å€‹ <code>Query</code> åƒæ•¸ã€‚è€Œåœ¨ <code>itemBuilder</code> å›èª¿ä¸­ï¼Œæˆ‘å€‘å¿…é ˆä½¿ç”¨ <code>QueryDocumentSnapshot</code>ï¼ˆé€™ä¹Ÿæ˜¯ Firebase ç‰¹æœ‰çš„ï¼‰ã€‚</p><p>Indeed, the whole point of using theÂ <a href=https://pub.dev/packages/firebase_ui_firestore>firebase_ui_firestore</a>Â package is that:</p><p>äº‹å¯¦ä¸Šï¼Œä½¿ç”¨ <a href=https://pub.dev/packages/firebase_ui_firestore>firebase_ui_firestore</a> å¥—ä»¶çš„æ ¸å¿ƒç›®çš„åœ¨æ–¼ï¼š</p><blockquote><p>Firebase UI for Firestore enables you to easily integrate your application UI with your Cloud Firestore database.</p><p>Firebase UI for Firestore è®“ä½ å¯ä»¥è¼•é¬†åœ°å°‡æ‡‰ç”¨ç¨‹å¼çš„ UI èˆ‡ Cloud Firestore è³‡æ–™åº«æ•´åˆã€‚</p></blockquote><p>So, whether weâ€™ve done this intentionally or not,Â <strong>weâ€™ve made a tradeoff</strong>.</p><p>å› æ­¤ï¼Œä¸ç®¡æˆ‘å€‘æ˜¯å¦æœ‰æ„è­˜åˆ°é€™é»ï¼Œ<strong>æˆ‘å€‘åšäº†ä¸€å€‹å–æ¨</strong>ã€‚</p><p>Weâ€™ve chosen to create a leaky abstraction (usingÂ <code>Query</code>Â in the public interface of our repository) in return for the ease of use of theÂ <code>FirestoreListView</code>Â widget.</p><p>æˆ‘å€‘é¸æ“‡å»ºç«‹ä¸€å€‹æ´©æ¼æ€§æŠ½è±¡ï¼ˆåœ¨å„²å­˜åº«çš„å…¬é–‹ä»‹é¢ä¸­ä½¿ç”¨ <code>Query</code>ï¼‰ï¼Œä»¥æ›å– <code>FirestoreListView</code> å…ƒä»¶çš„æ˜“ç”¨æ€§ã€‚</p><p>But this abstraction comes with someÂ <strong>tangible benefits</strong>Â because by usingÂ <code>FirestoreListView</code>,Â <a href=https://codewithandrea.com/articles/firestore-pagination-list-view/>we get pagination for free</a>Â and a convenient way toÂ <a href=https://pub.dev/packages/firebase_ui_firestore#loading-and-error-handling>handle loading and error states</a>.</p><p>ä½†é€™å€‹æŠ½è±¡å¸¶ä¾†äº†ä¸€äº›<strong>å¯¦éš›çš„å¥½è™•</strong>ï¼Œå› ç‚ºä½¿ç”¨ <code>FirestoreListView</code>ï¼Œ<a href=https://codewithandrea.com/articles/firestore-pagination-list-view/>æˆ‘å€‘å¯ä»¥å…è²»ç²å¾—åˆ†é åŠŸèƒ½</a>ï¼Œä»¥åŠä¸€ç¨®æ–¹ä¾¿çš„æ–¹å¼ä¾†<a href=https://pub.dev/packages/firebase_ui_firestore#loading-and-error-handling>è™•ç†åŠ è¼‰å’ŒéŒ¯èª¤ç‹€æ…‹</a>ã€‚</p><blockquote><p>Implementing Firestore pagination manually can be a lot of work. So if thereâ€™s an official package that does a good job at it, weâ€™d be silly not to use it. ğŸ˜‰</p><p>æ‰‹å‹•å¯¦ç¾ Firestore çš„åˆ†é åŠŸèƒ½å¯èƒ½éœ€è¦å¤§é‡å·¥ä½œã€‚å› æ­¤ï¼Œå¦‚æœæœ‰ä¸€å€‹å®˜æ–¹å¥—ä»¶èƒ½å¾ˆå¥½åœ°è™•ç†é€™äº›å•é¡Œï¼Œæˆ‘å€‘ç•¶ç„¶æ‡‰è©²ç”¨å®ƒã€‚ğŸ˜‰</p></blockquote><h3 id=revisiting-the-leaky-abstraction>Revisiting the Leaky Abstraction<a hidden class=anchor aria-hidden=true href=#revisiting-the-leaky-abstraction>#</a></h3><p>But letâ€™s suppose that weâ€™ve decided to move away from Cloud Firestore, and we want to make our code truly backend-agnostic.</p><p>ä½†å‡è¨­æˆ‘å€‘æ±ºå®šæ”¾æ£„ä½¿ç”¨ Cloud Firestoreï¼Œä¸¦å¸Œæœ›è®“ä»£ç¢¼çœŸæ­£åšåˆ°èˆ‡å¾Œç«¯ç„¡é—œã€‚</p><p>How can we do that?</p><p>æˆ‘å€‘è©²æ€éº¼åšï¼Ÿ</p><p>Well, assuming we choose another remote database thatÂ <strong>supports realtime listeners</strong>, we can modify our repository to use aÂ <code>Stream</code>Â and consume it in our widget using a regularÂ <code>ListView</code>, like this:</p><p>å‡è¨­æˆ‘å€‘é¸æ“‡å¦ä¸€å€‹æ”¯æŒ<strong>å¯¦æ™‚ç›£è½</strong>çš„é ç«¯è³‡æ–™åº«ï¼Œå¯ä»¥ä¿®æ”¹å„²å­˜åº«ä»¥ä½¿ç”¨ <code>Stream</code>ï¼Œä¸¦åœ¨å…ƒä»¶ä¸­é€éæ™®é€šçš„ <code>ListView</code> ä½¿ç”¨å®ƒï¼Œä¾‹å¦‚ï¼š</p><p><img alt="Updated implementation: the presentation layer is now backend-agnostic as it no longer depends on the Query type" loading=lazy src=https://codewithandrea.com/articles/abstraction-repository-pattern-flutter/images/presentation-data-layer-stream.webp></p><p>Hereâ€™s what theÂ <strong>public interface</strong>Â would look like:</p><p>ä»¥ä¸‹æ˜¯<strong>å…¬é–‹ä»‹é¢</strong>çš„æ¨£å­ï¼š</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dart data-lang=dart><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ItemsRepository</span> {
</span></span><span style=display:flex><span>  Stream<span style=color:#f92672>&lt;</span>List<span style=color:#f92672>&lt;</span>Item<span style=color:#f92672>&gt;&gt;</span> itemsStream() { ... }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And hereâ€™s what the complete repository would look like:</p><p>å®Œæ•´çš„å„²å­˜åº«ä»£ç¢¼å¦‚ä¸‹ï¼š</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dart data-lang=dart><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ItemsRepository</span> {
</span></span><span style=display:flex><span>  ItemsRepository(<span style=color:#66d9ef>this</span>._firestore);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>final</span> FirebaseFirestore _firestore;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  Stream<span style=color:#f92672>&lt;</span>List<span style=color:#f92672>&lt;</span>Item<span style=color:#f92672>&gt;&gt;</span> itemsStream() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> _firestore
</span></span><span style=display:flex><span>        .collection(<span style=color:#e6db74>&#39;items&#39;</span>)
</span></span><span style=display:flex><span>        .withConverter(
</span></span><span style=display:flex><span>          fromFirestore: (snapshot, _) <span style=color:#f92672>=&gt;</span> Item.fromMap(snapshot.data()<span style=color:#f92672>!</span>),
</span></span><span style=display:flex><span>          toFirestore: (item, _) <span style=color:#f92672>=&gt;</span> item.toMap(),
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>        .orderBy(<span style=color:#e6db74>&#39;name&#39;</span>)
</span></span><span style=display:flex><span>        <span style=color:#75715e>// needed to transform a Query&lt;User&gt; to a Stream&lt;List&lt;Item&gt;&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        .snapshots()
</span></span><span style=display:flex><span>        .map((snapshot) <span style=color:#f92672>=&gt;</span>
</span></span><span style=display:flex><span>            snapshot.docs.map((snapshot) <span style=color:#f92672>=&gt;</span> snapshot.data()).toList());
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This new API is backend-agnostic because it only usesÂ <strong>built-in types</strong>Â (such asÂ <code>Stream</code>) and typesÂ <strong>we have defined</strong>Â (such as theÂ <code>Item</code>Â class).</p><p>é€™å€‹æ–°çš„ API æ˜¯å¾Œç«¯ç„¡é—œçš„ï¼Œå› ç‚ºå®ƒåªä½¿ç”¨äº†<strong>å…§å»ºé¡å‹</strong>ï¼ˆä¾‹å¦‚ <code>Stream</code>ï¼‰å’Œ<strong>æˆ‘å€‘è‡ªå·±å®šç¾©çš„é¡å‹</strong>ï¼ˆä¾‹å¦‚ <code>Item</code> é¡åˆ¥ï¼‰ã€‚</p><p>If we want to consume the new Stream-based API in the UI, we can useÂ <code>StreamBuilder</code>Â (<a href=https://codewithandrea.com/articles/flutter-use-async-value-not-future-stream-builder/>which is quite clunky</a>) - or, better still - create aÂ <code>StreamProvider</code>:</p><p>å¦‚æœæˆ‘å€‘æƒ³åœ¨ UI ä¸­ä½¿ç”¨æ–°çš„åŸºæ–¼ Stream çš„ APIï¼Œå¯ä»¥ä½¿ç”¨ <code>StreamBuilder</code>ï¼ˆ<a href=https://codewithandrea.com/articles/flutter-use-async-value-not-future-stream-builder/>é›–ç„¶æœ‰äº›ç¹ç‘£</a>ï¼‰â€”â€”æˆ–è€…æ›´å¥½åœ°ï¼Œå‰µå»ºä¸€å€‹ <code>StreamProvider</code>ï¼š</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dart data-lang=dart><span style=display:flex><span><span style=color:#66d9ef>final</span> itemsStreamProvider <span style=color:#f92672>=</span> StreamProvider.autoDispose<span style=color:#f92672>&lt;</span>List<span style=color:#f92672>&lt;</span>Item<span style=color:#f92672>&gt;&gt;</span>((ref) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> ref.watch(itemsRepositoryProvider).itemsStream();
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><p>Then, in the UI, we can do this:</p><p>åœ¨ UI ä¸­å¯ä»¥é€™æ¨£ä½¿ç”¨ï¼š</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dart data-lang=dart><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ItemsList</span> <span style=color:#66d9ef>extends</span> ConsumerWidget {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> ItemsList({<span style=color:#66d9ef>super</span>.key});
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#960050;background-color:#1e0010>@</span>override
</span></span><span style=display:flex><span>  Widget build(BuildContext context, WidgetRef ref) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// get an AsyncValue&lt;Item&gt; by watching the stream provider
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>final</span> itemsAsync <span style=color:#f92672>=</span> ref.watch(itemsStreamProvider);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// use pattern matching to handle the data, loading, error states
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> itemsAsync.when(
</span></span><span style=display:flex><span>      data: (items) <span style=color:#f92672>=&gt;</span> ListView.builder(
</span></span><span style=display:flex><span>        itemBuilder: (context, index) {
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>final</span> item <span style=color:#f92672>=</span> items[index];
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>return</span> Text(<span style=color:#e6db74>&#39;Item name is </span><span style=color:#e6db74>${</span>item.name<span style=color:#e6db74>}</span><span style=color:#e6db74>&#39;</span>);
</span></span><span style=display:flex><span>        },
</span></span><span style=display:flex><span>        itemCount: items.length,
</span></span><span style=display:flex><span>      ),
</span></span><span style=display:flex><span>      loading: () <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>const</span> CircularProgressIndicator(),
</span></span><span style=display:flex><span>      error: (e, st) <span style=color:#f92672>=&gt;</span> Text(e.toString()),
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Note that this is more code than the original implementation based onÂ <code>FirestoreListView</code>. AndÂ <strong>we no longer get the built-in pagination support</strong>.</p><p>è«‹æ³¨æ„ï¼Œé€™æ¯”åŸºæ–¼ <code>FirestoreListView</code> çš„åŸå§‹å¯¦ç¾ä»£ç¢¼æ›´å¤šã€‚è€Œä¸”ï¼Œ<strong>æˆ‘å€‘ä¸å†ç²å¾—å…§å»ºçš„åˆ†é æ”¯æŒ</strong>ã€‚</p><p>But we can confidently say that this implementation isÂ <strong>truly backend-agnostic</strong>.</p><p>ä½†æˆ‘å€‘å¯ä»¥è‡ªä¿¡åœ°èªªï¼Œé€™ç¨®å¯¦ç¾æ˜¯<strong>çœŸæ­£å¾Œç«¯ç„¡é—œçš„</strong>ã€‚</p><p>And if later on we decided to implement aÂ <code>SupabaseItemsRepository</code>, the UI codeÂ <strong>would remain the same</strong>.</p><p>å¦‚æœå¾Œä¾†æˆ‘å€‘æ±ºå®šå¯¦ç¾ä¸€å€‹ <code>SupabaseItemsRepository</code>ï¼ŒUI ä»£ç¢¼<strong>å°‡ä¿æŒä¸è®Š</strong>ã€‚</p><h3 id=when-are-abstractions-worth-it>When are abstractions worth it?<a hidden class=anchor aria-hidden=true href=#when-are-abstractions-worth-it>#</a></h3><p>So far, we have considered these two abstractions:</p><p>åˆ°ç›®å‰ç‚ºæ­¢ï¼Œæˆ‘å€‘è€ƒæ…®äº†ä»¥ä¸‹å…©ç¨®æŠ½è±¡ï¼š</p><ol><li><p>Moving the data-access code into a repository</p></li><li><p>ReplaceÂ <code>Query&lt;Item></code>Â withÂ <code>Stream&lt;List&lt;Item></code></p></li><li><p>å°‡è³‡æ–™å­˜å–ä»£ç¢¼ç§»åˆ°ä¸€å€‹å„²å­˜åº«ä¸­</p></li><li><p>å°‡ <code>Query&lt;Item></code> æ›¿æ›ç‚º <code>Stream&lt;List&lt;Item>></code></p></li></ol><p>The first abstraction is worth it, because leads to a better separation of concerns between UI and data-access logic.</p><p>ç¬¬ä¸€ç¨®æŠ½è±¡æ˜¯å€¼å¾—çš„ï¼Œå› ç‚ºå®ƒåœ¨ UI å’Œè³‡æ–™å­˜å–é‚è¼¯ä¹‹é–“å¯¦ç¾äº†æ›´å¥½çš„è²¬ä»»åˆ†é›¢ã€‚</p><p>But the second one isn&rsquo;t, as we had to write more code, while losing some useful functionality (pagination) along the way.</p><p>ä½†ç¬¬äºŒç¨®æŠ½è±¡å‰‡ä¸å€¼å¾—ï¼Œå› ç‚ºæˆ‘å€‘å¿…é ˆæ’°å¯«æ›´å¤šä»£ç¢¼ï¼Œä¸¦ä¸”åœ¨æ­¤éç¨‹ä¸­å¤±å»äº†æŸäº›æœ‰ç”¨çš„åŠŸèƒ½ï¼ˆä¾‹å¦‚åˆ†é ï¼‰ã€‚</p><p>But there&rsquo;s one more thing we need to consider. ğŸ‘‡</p><p>ä½†é‚„æœ‰ä¸€ä»¶äº‹éœ€è¦è€ƒæ…®ã€‚ğŸ‘‡</p><h3 id=note-about-testing>Note about testing<a hidden class=anchor aria-hidden=true href=#note-about-testing>#</a></h3><p>One of the benefits of abstraction is that we can more easily test our code.</p><p>æŠ½è±¡çš„ä¸€å€‹å¥½è™•æ˜¯æˆ‘å€‘å¯ä»¥æ›´è¼•é¬†åœ°æ¸¬è©¦ä»£ç¢¼ã€‚</p><p>So what can we say about testing with regards to theÂ <code>Query</code>Â vsÂ <code>Stream</code>-based implementations in the example above?</p><p>é‚£éº¼ï¼Œå°æ–¼ä¸Šè¿°ä¾‹å­ä¸­çš„åŸºæ–¼ <code>Query</code> å’ŒåŸºæ–¼ <code>Stream</code> çš„å¯¦ç¾ï¼Œæˆ‘å€‘èƒ½èªªäº›ä»€éº¼å‘¢ï¼Ÿ</p><p>Letâ€™s consider ourÂ <code>ItemsRepository</code>Â once again:</p><p>å†çœ‹çœ‹æˆ‘å€‘çš„ <code>ItemsRepository</code>ï¼š</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dart data-lang=dart><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ItemsRepository</span> {
</span></span><span style=display:flex><span>  ...
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// first solution using a query
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  Query<span style=color:#f92672>&lt;</span>Item<span style=color:#f92672>&gt;</span> itemsQuery() { ... }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// second solution using a stream
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  Stream<span style=color:#f92672>&lt;</span>List<span style=color:#f92672>&lt;</span>Item<span style=color:#f92672>&gt;&gt;</span> itemsStream() { ... }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>How can we mock theÂ <code>ItemsRepository</code>Â so that it returns the data we want?</p><p>å¦‚ä½•æ¨¡æ“¬ <code>ItemsRepository</code>ï¼Œä»¥ä¾¿å®ƒè¿”å›æˆ‘å€‘æƒ³è¦çš„è³‡æ–™ï¼Ÿ</p><p>If we useÂ <a href=https://pub.dev/packages/mocktail>mocktail</a>, we can create our mock like this:</p><p>å¦‚æœæˆ‘å€‘ä½¿ç”¨ <a href=https://pub.dev/packages/mocktail>mocktail</a>ï¼Œå¯ä»¥é€™æ¨£å‰µå»ºæ¨¡æ“¬ï¼š</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dart data-lang=dart><span style=display:flex><span><span style=color:#66d9ef>import</span> <span style=color:#e6db74>&#39;package:mocktail/mocktail.dart&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MockItemsRepository</span> <span style=color:#66d9ef>extends</span> Mock <span style=color:#66d9ef>implements</span> ItemsRepository {}
</span></span></code></pre></div><p>And then, we can stub theÂ <code>itemsQuery()</code>Â andÂ <code>itemsStream()</code>Â methods so they can respond when called.</p><p>æ¥è‘—ï¼Œæˆ‘å€‘å¯ä»¥æ¨¡æ“¬ <code>itemsQuery()</code> å’Œ <code>itemsStream()</code> æ–¹æ³•ï¼Œä½¿å®ƒå€‘åœ¨è¢«èª¿ç”¨æ™‚è¿”å›ç‰¹å®šéŸ¿æ‡‰ã€‚</p><p>In the stream-based approach, we could setup our mock like this:</p><p>åœ¨åŸºæ–¼ Stream çš„æ–¹æ³•ä¸­ï¼Œæˆ‘å€‘å¯ä»¥é€™æ¨£è¨­ç½®æ¨¡æ“¬ï¼š</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dart data-lang=dart><span style=display:flex><span><span style=color:#66d9ef>final</span> mockRepo <span style=color:#f92672>=</span> MockItemsRepository();
</span></span><span style=display:flex><span>when(() <span style=color:#f92672>=&gt;</span> mockRepo.itemsStream()).thenAnswer(
</span></span><span style=display:flex><span> (invocation) <span style=color:#f92672>=&gt;</span> Stream.value([
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>const</span> Item(name: <span style=color:#e6db74>&#39;Beer&#39;</span>),
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>const</span> Item(name: <span style=color:#e6db74>&#39;Wine&#39;</span>),
</span></span><span style=display:flex><span> ]),
</span></span><span style=display:flex><span>);
</span></span></code></pre></div><p>But in the query-based approach, we&rsquo;re out of luck:</p><p>ä½†åœ¨åŸºæ–¼ Query çš„æ–¹æ³•ä¸­ï¼Œæƒ…æ³å°±ä¸å¦™äº†ï¼š</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dart data-lang=dart><span style=display:flex><span><span style=color:#66d9ef>final</span> mockRepo <span style=color:#f92672>=</span> MockItemsRepository();
</span></span><span style=display:flex><span><span style=color:#75715e>// ! Abstract classes can&#39;t be instantiated.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// ! Try creating an instance of a concrete subtype.        
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>when(() <span style=color:#f92672>=&gt;</span> mockRepo.itemsQuery()).thenReturn(Query());
</span></span></code></pre></div><p>Thatâ€™s becauseÂ <a href=https://pub.dev/documentation/cloud_firestore/latest/cloud_firestore/Query-class.html><code>Query</code></a>Â is defined as an abstract class inside theÂ <a href=https://pub.dev/packages/cloud_firestore>cloud_firestore</a>Â package.</p><p>å› ç‚º <a href=https://pub.dev/documentation/cloud_firestore/latest/cloud_firestore/Query-class.html><code>Query</code></a> æ˜¯åœ¨ <a href=https://pub.dev/packages/cloud_firestore>cloud_firestore</a> å¥—ä»¶å…§å®šç¾©çš„ä¸€å€‹æŠ½è±¡é¡åˆ¥ã€‚</p><p>But letâ€™s not give up just yet, for we can create aÂ <code>MockQuery</code>Â class:</p><p>ä½†åˆ¥æ€¥è‘—æ”¾æ£„ï¼Œæˆ‘å€‘é‚„å¯ä»¥å‰µå»ºä¸€å€‹ <code>MockQuery</code> é¡åˆ¥ï¼š</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dart data-lang=dart><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MockQuery</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>extends</span> Mock <span style=color:#66d9ef>implements</span> Query<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> {}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>final</span> mockRepo <span style=color:#f92672>=</span> MockItemsRepository();
</span></span><span style=display:flex><span><span style=color:#66d9ef>final</span> mockQuery <span style=color:#f92672>=</span> MockQuery();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>when(() <span style=color:#f92672>=&gt;</span> mockRepo.itemsQuery()).thenReturn(mockQuery);
</span></span></code></pre></div><p>But as it turns out, we get this warning:</p><p>ä¸åƒ…å¦‚æ­¤ï¼Œæˆ‘å€‘æœƒçœ‹åˆ°é€™æ¨£çš„è­¦å‘Šï¼š</p><pre tabindex=0><code>The class &#39;Query&#39; shouldn&#39;t be extended, mixed in, or implemented because it&#39;s sealed.

Try composing instead of inheriting, or refer to the documentation of &#39;Query&#39; for more information.
</code></pre><p>This is no good. And if we look at theÂ <a href=https://pub.dev/documentation/cloud_firestore/latest/cloud_firestore/Query-class.html>documentation for the Query class</a>, we see that it contains nearly 20 methods. And it would be hard to figure out which ones we need to stub to get the test working.</p><p>é€™ä¸¦ä¸å¥½ã€‚è€Œä¸”ï¼ŒæŸ¥çœ‹ <a href=https://pub.dev/documentation/cloud_firestore/latest/cloud_firestore/Query-class.html>Query é¡åˆ¥çš„æ–‡ä»¶</a> å¾Œç™¼ç¾ï¼Œå®ƒåŒ…å«äº†è¿‘ 20 å€‹æ–¹æ³•ã€‚è¦å¼„æ¸…æ¥šéœ€è¦æ¨¡æ“¬å“ªäº›æ–¹æ³•æ‰èƒ½è®“æ¸¬è©¦æ­£å¸¸é‹è¡Œï¼Œéå¸¸å›°é›£ã€‚</p><p><strong>Bottom line:</strong>Â itâ€™s really hard to write tests that use theÂ <code>Query</code>Â class since itÂ <strong>is not meant to be mocked</strong>.</p><p><strong>çµè«–ï¼š</strong> ä½¿ç”¨ <code>Query</code> é¡åˆ¥çš„æ¸¬è©¦éå¸¸é›£æ’°å¯«ï¼Œå› ç‚ºå®ƒ<strong>ä¸¦ä¸æ˜¯ç‚ºäº†è¢«æ¨¡æ“¬è€Œè¨­è¨ˆçš„</strong>ã€‚</p><p>So when you design the API (public interface) of your repositories, keep testing in mind.</p><p>å› æ­¤ï¼Œåœ¨è¨­è¨ˆå„²å­˜åº«çš„ APIï¼ˆå…¬é–‹ä»‹é¢ï¼‰æ™‚ï¼Œè«‹è€ƒæ…®åˆ°æ¸¬è©¦éœ€æ±‚ã€‚</p><p>Indeed, sometimes you have to make a trade betweenÂ <strong>ease of use</strong>Â andÂ <strong>ease of testing</strong>. And you can choose different abstractions depending on what&rsquo;s most important to you.</p><p>çš„ç¢ºï¼Œæœ‰æ™‚ä½ éœ€è¦åœ¨<strong>æ˜“ç”¨æ€§</strong>å’Œ<strong>æ¸¬è©¦ä¾¿åˆ©æ€§</strong>ä¹‹é–“åšå‡ºå–æ¨ã€‚æ ¹æ“šä½ èªç‚ºæœ€é‡è¦çš„é»ï¼Œå¯ä»¥é¸æ“‡ä¸åŒçš„æŠ½è±¡ã€‚</p><hr><p>Learning to choose the right abstractions is a good skill to have.</p><p>å­¸ç¿’é¸æ“‡æ­£ç¢ºçš„æŠ½è±¡æ˜¯ä¸€é …éå¸¸æœ‰ç”¨çš„æŠ€èƒ½ã€‚</p><p>So letâ€™s consider some additional examples so that we can build some more intuition. ğŸ‘‡</p><p>å› æ­¤ï¼Œæˆ‘å€‘ä¾†çœ‹ä¸€äº›é¡å¤–çš„ä¾‹å­ï¼Œè—‰æ­¤å»ºç«‹æ›´å¤šçš„ç›´è¦ºã€‚ğŸ‘‡</p><h2 id=example-firebaseauth-wrapper>Example: FirebaseAuth wrapper<a hidden class=anchor aria-hidden=true href=#example-firebaseauth-wrapper>#</a></h2><p>When adding user authentication to your app, we need to work directly with theÂ <code>FirebaseAuth</code>Â class (unless we use the Firebase UI packages).</p><p>ç•¶æˆ‘å€‘å°‡ç”¨æˆ¶èº«ä»½é©—è­‰åŠŸèƒ½æ·»åŠ åˆ°æ‡‰ç”¨ä¸­æ™‚ï¼Œé€šå¸¸éœ€è¦ç›´æ¥èˆ‡ <code>FirebaseAuth</code> é¡é€²è¡Œäº¤äº’ï¼ˆé™¤éæˆ‘å€‘ä½¿ç”¨ Firebase UI å¥—ä»¶ï¼‰ã€‚</p><p>Here are some of the methods we can find inside this class (along with many others):</p><p>ä»¥ä¸‹æ˜¯è©²é¡çš„ä¸€äº›æ–¹æ³•ï¼ˆé‚„æœ‰è¨±å¤šå…¶ä»–æ–¹æ³•ï¼‰ï¼š</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dart data-lang=dart><span style=display:flex><span><span style=color:#75715e>// defined in firebase_auth.dart
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>FirebaseAuth</span> {
</span></span><span style=display:flex><span>  Future<span style=color:#f92672>&lt;</span>UserCredential<span style=color:#f92672>&gt;</span> signInWithEmailAndPassword({
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>required</span> <span style=color:#66d9ef>String</span> email,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>required</span> <span style=color:#66d9ef>String</span> password,
</span></span><span style=display:flex><span>  });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  Future<span style=color:#f92672>&lt;</span>UserCredential<span style=color:#f92672>&gt;</span> createUserWithEmailAndPassword({
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>required</span> <span style=color:#66d9ef>String</span> email,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>required</span> <span style=color:#66d9ef>String</span> password,
</span></span><span style=display:flex><span>  });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  Future<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>void</span><span style=color:#f92672>&gt;</span> signOut();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  Stream<span style=color:#f92672>&lt;</span>User<span style=color:#f92672>?&gt;</span> authStateChanges();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  User<span style=color:#f92672>?</span> <span style=color:#66d9ef>get</span> currentUser;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Some of these methods returnÂ <code>UserCredential</code>Â andÂ <code>User</code>, which are types that are also defined in the same package.</p><p>å…¶ä¸­ä¸€äº›æ–¹æ³•æœƒè¿”å› <code>UserCredential</code> å’Œ <code>User</code>ï¼Œé€™äº›é¡å‹ä¹Ÿéƒ½å®šç¾©åœ¨ç›¸åŒçš„å¥—ä»¶ä¸­ã€‚</p><p>But if we use this classÂ <strong>directly</strong>Â in our code, we have two problems:</p><p>ä½†æ˜¯ï¼Œå¦‚æœæˆ‘å€‘<strong>ç›´æ¥</strong>åœ¨ä»£ç¢¼ä¸­ä½¿ç”¨é€™å€‹é¡ï¼Œå°±æœƒé‡åˆ°å…©å€‹å•é¡Œï¼š</p><ul><li><p>UsingÂ <code>FirebaseAuth.instance</code>Â all over the place makes our code less testable</p></li><li><p>We have to importÂ <code>firebase_auth.dart</code>Â every time we want to use the firebase_auth APIs</p></li><li><p>åœ¨ä»£ç¢¼ä¸­åˆ°è™•ä½¿ç”¨ <code>FirebaseAuth.instance</code> æœƒè®“ä»£ç¢¼è®Šå¾—é›£ä»¥æ¸¬è©¦ã€‚</p></li><li><p>æ¯æ¬¡ä½¿ç”¨ <code>firebase_auth</code> çš„ API éƒ½å¿…é ˆå°å…¥ <code>firebase_auth.dart</code>ã€‚</p></li></ul><p>Not great, because the codebase becomesÂ <strong>tightly coupled</strong>Â to the firebase_auth package.</p><p>é€™æ¨£çš„ä»£ç¢¼ä¸å¤ªç†æƒ³ï¼Œå› ç‚ºä»£ç¢¼åº«æœƒèˆ‡ <code>firebase_auth</code> å¥—ä»¶<strong>ç·Šå¯†è€¦åˆ</strong>ã€‚</p><p>Let&rsquo;s see if we can do better. ğŸ‘‡</p><p>çœ‹çœ‹æœ‰æ²’æœ‰æ›´å¥½çš„åšæ³•ğŸ‘‡</p><h3 id=step-1-add-a-provider>Step 1: Add a Provider<a hidden class=anchor aria-hidden=true href=#step-1-add-a-provider>#</a></h3><p>The first step is to create a provider:</p><p>ç¬¬ä¸€æ­¥æ˜¯å‰µå»ºä¸€å€‹ providerï¼š</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dart data-lang=dart><span style=display:flex><span><span style=color:#66d9ef>final</span> firebaseAuthProvider <span style=color:#f92672>=</span> Provider<span style=color:#f92672>&lt;</span>FirebaseAuth<span style=color:#f92672>&gt;</span>((ref) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> FirebaseAuth.instance;
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><p>And then, we canÂ <strong>watch</strong>Â orÂ <strong>read</strong>Â theÂ <code>firebaseAuthProvider</code>Â as needed.</p><p>ç„¶å¾Œï¼Œæˆ‘å€‘å¯ä»¥æ ¹æ“šéœ€è¦ <strong>watch</strong> æˆ– <strong>read</strong> <code>firebaseAuthProvider</code>ã€‚</p><blockquote><p>If youâ€™re unfamiliar with the difference betweenÂ <code>ref.watch</code>Â andÂ <code>ref.read</code>Â with Riverpod, check the official documentation page aboutÂ <a href=https://riverpod.dev/docs/concepts/reading>Reading a Provider</a>.</p><p>å¦‚æœä¸æ¸…æ¥š Riverpod ä¸­ <code>ref.watch</code> å’Œ <code>ref.read</code> çš„å€åˆ¥ï¼Œå¯ä»¥åƒè€ƒå®˜æ–¹æ–‡ä»¶ï¼š<a href=https://riverpod.dev/docs/concepts/reading>Reading a Provider</a>ã€‚</p></blockquote><p>This will make our code more testable (since we can overrideÂ <code>firebaseAuthProvider</code>Â with a mock in our tests).</p><p>é€™å°‡ä½¿ä»£ç¢¼æ›´å…·å¯æ¸¬è©¦æ€§ï¼ˆå› ç‚ºæˆ‘å€‘å¯ä»¥åœ¨æ¸¬è©¦ä¸­ç”¨ mock è¦†è“‹ <code>firebaseAuthProvider</code>ï¼‰ã€‚</p><p>But any code that uses theÂ <code>firebaseAuthProvider</code>Â will still depend onÂ <code>firebase_auth.dart</code>, which can lead to maintenance issues (for example, when upgrading to a new version of firebase_auth that contains breaking changes).</p><p>ç„¶è€Œï¼Œä»»ä½•ä½¿ç”¨ <code>firebaseAuthProvider</code> çš„ä»£ç¢¼ä»ç„¶æœƒä¾è³´ <code>firebase_auth.dart</code>ï¼Œé€™å¯èƒ½å¸¶ä¾†ç¶­è­·å•é¡Œï¼ˆä¾‹å¦‚ï¼Œå‡ç´šåˆ°æœ‰é‡å¤§è®Šæ›´çš„ <code>firebase_auth</code> æ–°ç‰ˆæœ¬æ™‚ï¼‰ã€‚</p><h3 id=step-2-write-an-authrepository>Step 2: Write an AuthRepository<a hidden class=anchor aria-hidden=true href=#step-2-write-an-authrepository>#</a></h3><p>The next step is to create a separateÂ <code>AuthRepository</code>Â class that acts as a wrapper forÂ <code>FirebaseAuth</code>.</p><p>ä¸‹ä¸€æ­¥æ˜¯å‰µå»ºä¸€å€‹ç¨ç«‹çš„ <code>AuthRepository</code> é¡ï¼Œä½œç‚º <code>FirebaseAuth</code> çš„åŒ…è£å™¨ã€‚</p><p>As a first attempt, we could write this code:</p><p>æˆ‘å€‘å¯ä»¥å…ˆå¯«å‡ºå¦‚ä¸‹ä»£ç¢¼ï¼š</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dart data-lang=dart><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>AuthRepository</span> {
</span></span><span style=display:flex><span>  AuthRepository(<span style=color:#66d9ef>this</span>._auth);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>final</span> FirebaseAuth _auth;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// leaks [UserCredential]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  Future<span style=color:#f92672>&lt;</span>UserCredential<span style=color:#f92672>&gt;</span> signInWithEmailAndPassword(<span style=color:#66d9ef>String</span> email, <span style=color:#66d9ef>String</span> password) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> _auth.signInWithEmailAndPassword(
</span></span><span style=display:flex><span>      email: email,
</span></span><span style=display:flex><span>      password: password,
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// leaks [UserCredential]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  Future<span style=color:#f92672>&lt;</span>UserCredential<span style=color:#f92672>&gt;</span> createUserWithEmailAndPassword(<span style=color:#66d9ef>String</span> email, <span style=color:#66d9ef>String</span> password) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> _auth.createUserWithEmailAndPassword(
</span></span><span style=display:flex><span>      email: email,
</span></span><span style=display:flex><span>      password: password,
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  Future<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>void</span><span style=color:#f92672>&gt;</span> signOut() <span style=color:#f92672>=&gt;</span> _auth.signOut();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// leaks [User]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  Stream<span style=color:#f92672>&lt;</span>User<span style=color:#f92672>?&gt;</span> authStateChanges() <span style=color:#f92672>=&gt;</span> _auth.authStateChanges();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// leaks [User]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  User<span style=color:#f92672>?</span> <span style=color:#66d9ef>get</span> currentUser <span style=color:#f92672>=&gt;</span> _auth.currentUser;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This is just a simple wrapper, but we can immediately notice that the public interface is leaking theÂ <code>UserCredential</code>Â andÂ <code>User</code>Â types (from firebase_auth).</p><p>é€™åªæ˜¯ä¸€å€‹ç°¡å–®çš„åŒ…è£å™¨ï¼Œä½†æˆ‘å€‘å¯ä»¥ç«‹å³æ³¨æ„åˆ°ï¼Œå…¶å…¬å…±ä»‹é¢æ´©éœ²äº† <code>UserCredential</code> å’Œ <code>User</code> é¡å‹ï¼ˆä¾†è‡ª <code>firebase_auth</code>ï¼‰ã€‚</p><p><strong>This is probably fine</strong>Â as long as we donâ€™t plan to migrate to a different authentication system, or don&rsquo;t care too much about testing (more on this below).</p><p><strong>é€™å¯èƒ½æ²’å•é¡Œ</strong>ï¼Œå‰ææ˜¯æˆ‘å€‘ä¸æ‰“ç®—é·ç§»åˆ°å…¶ä»–èº«ä»½é©—è­‰ç³»çµ±ï¼Œæˆ–ä¸å¤ªåœ¨æ„æ¸¬è©¦ï¼ˆå¾ŒçºŒæœƒè©³è¿°ï¼‰ã€‚</p><p>With the methods we added, we can already:</p><p>é€šéæ·»åŠ çš„æ–¹æ³•ï¼Œæˆ‘å€‘å·²ç¶“å¯ä»¥åšåˆ°ä»¥ä¸‹å¹¾é»ï¼š</p><ul><li><p>route the user to a â€œlogged inâ€ or â€œlogged outâ€ page depending on the authentication state inÂ <code>authStateChanges()</code></p></li><li><p>sign in once the user submits an email & password form, or sign out when the user clicks on a logout button</p></li><li><p>æ ¹æ“š <code>authStateChanges()</code> çš„èº«ä»½é©—è­‰ç‹€æ…‹ï¼Œå°‡ç”¨æˆ¶è·¯ç”±åˆ°â€œå·²ç™»å…¥â€æˆ–â€œå·²ç™»å‡ºâ€é é¢ã€‚</p></li><li><p>ç•¶ç”¨æˆ¶æäº¤éƒµç®±å’Œå¯†ç¢¼è¡¨å–®æ™‚ç™»å…¥ï¼Œæˆ–é»æ“Šç™»å‡ºæŒ‰éˆ•æ™‚ç™»å‡ºã€‚</p></li></ul><p>If we need additional methods from theÂ <code>FirebaseAuth</code>Â class, we can just add them to theÂ <code>AuthRepository</code>Â and use them.</p><p>å¦‚æœæˆ‘å€‘éœ€è¦ <code>FirebaseAuth</code> é¡ä¸­çš„å…¶ä»–æ–¹æ³•ï¼Œåªéœ€å°‡å®ƒå€‘æ·»åŠ åˆ° <code>AuthRepository</code> ä¸¦ä½¿ç”¨å³å¯ã€‚</p><p>But sometimes, the methods we need are not in theÂ <code>AuthRepository</code>class. For example, if we want to send a verification email, we need to call a method that belongs to theÂ <code>User</code>Â class:</p><p>ä½†æ˜¯ï¼Œæœ‰æ™‚æˆ‘å€‘éœ€è¦çš„æ–¹æ³•ä¸¦ä¸åœ¨ <code>AuthRepository</code> é¡ä¸­ã€‚ä¾‹å¦‚ï¼Œè‹¥æˆ‘å€‘æƒ³ç™¼é€é©—è­‰éƒµä»¶ï¼Œå°±éœ€è¦èª¿ç”¨å±¬æ–¼ <code>User</code> é¡çš„æ–¹æ³•ï¼š</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dart data-lang=dart><span style=display:flex><span><span style=color:#75715e>// part of firebase_auth
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>User</span> {
</span></span><span style=display:flex><span>  Future<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>void</span><span style=color:#f92672>&gt;</span> sendEmailVerification([
</span></span><span style=display:flex><span>    ActionCodeSettings<span style=color:#f92672>?</span> actionCodeSettings,
</span></span><span style=display:flex><span>  ]);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=step-3-optional-write-a-wrapper-for-the-user-class>Step 3 (optional): Write a wrapper for the User class<a hidden class=anchor aria-hidden=true href=#step-3-optional-write-a-wrapper-for-the-user-class>#</a></h3><p>Now, letâ€™s assume we really want to make our data layer backend-agnostic, such that theÂ <code>AuthRepository</code>Â class doesnâ€™t expose any types from theÂ <a href=https://pub.dev/packages/firebase_auth>firebase_auth</a>Â package.</p><p>ç¾åœ¨ï¼Œå‡è¨­æˆ‘å€‘çœŸçš„æƒ³è®“æ•¸æ“šå±¤èˆ‡å¾Œç«¯ç„¡é—œï¼Œé€™æ¨£ <code>AuthRepository</code> é¡å°±ä¸æœƒæš´éœ²ä»»ä½•ä¾†è‡ª <a href=https://pub.dev/packages/firebase_auth>firebase_auth</a> å¥—ä»¶çš„é¡å‹ã€‚</p><p>Can we do that while retaining the ability to send a verification email or call any other methods from theÂ <code>User</code>Â class?</p><p>æˆ‘å€‘æ˜¯å¦èƒ½åœ¨ä¿ç•™ç™¼é€é©—è­‰éƒµä»¶æˆ–èª¿ç”¨å…¶ä»– <code>User</code> é¡æ–¹æ³•çš„èƒ½åŠ›çš„åŒæ™‚åšåˆ°é€™ä¸€é»ï¼Ÿ</p><p>Well, letâ€™s try to write a wrapper for theÂ <code>User</code>Â class.</p><p>æˆ‘å€‘å¯ä»¥è©¦è‘—ç‚º <code>User</code> é¡ç·¨å¯«ä¸€å€‹åŒ…è£å™¨ã€‚</p><p>We could start by creating anÂ <strong>abstract class</strong>Â that contains theÂ <strong>methods and fields</strong>Â we care about:</p><p>é¦–å…ˆï¼Œæˆ‘å€‘å¯ä»¥å‰µå»ºä¸€å€‹<strong>æŠ½è±¡é¡åˆ¥</strong>ï¼Œå…¶ä¸­åŒ…å«æˆ‘å€‘é—œå¿ƒçš„<strong>æ–¹æ³•å’Œå­—æ®µ</strong>ï¼š</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dart data-lang=dart><span style=display:flex><span><span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>AppUser</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>String</span> <span style=color:#66d9ef>get</span> uid;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>String</span><span style=color:#f92672>?</span> <span style=color:#66d9ef>get</span> email;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>bool</span> <span style=color:#66d9ef>get</span> emailVerified;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  Future<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>void</span><span style=color:#f92672>&gt;</span> sendEmailVerification();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Then, we could implement aÂ <code>FirebaseAppUser</code>Â thatÂ <strong>implements</strong>Â <code>AppUser</code>, by holding on to the underlyingÂ <code>User</code>Â <strong>as a private variable</strong>:</p><p>ç„¶å¾Œï¼Œæˆ‘å€‘å¯ä»¥å¯¦ç¾ä¸€å€‹ <code>FirebaseAppUser</code> é¡ï¼Œé€šéå°‡åº•å±¤çš„ <code>User</code> ä½œç‚º<strong>ç§æœ‰è®Šæ•¸</strong>ä¾†å¯¦ç¾ <code>AppUser</code>ï¼š</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dart data-lang=dart><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>FirebaseAppUser</span> <span style=color:#66d9ef>implements</span> AppUser {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> FirebaseAppUser(<span style=color:#66d9ef>this</span>._user);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>final</span> User _user; <span style=color:#75715e>// private
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>  <span style=color:#960050;background-color:#1e0010>@</span>override
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>String</span> <span style=color:#66d9ef>get</span> uid <span style=color:#f92672>=&gt;</span> _user.uid;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#960050;background-color:#1e0010>@</span>override
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>String</span><span style=color:#f92672>?</span> <span style=color:#66d9ef>get</span> email <span style=color:#f92672>=&gt;</span> _user.email;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#960050;background-color:#1e0010>@</span>override
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>bool</span> <span style=color:#66d9ef>get</span> emailVerified <span style=color:#f92672>=&gt;</span> _user.emailVerified;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#960050;background-color:#1e0010>@</span>override
</span></span><span style=display:flex><span>  Future<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>void</span><span style=color:#f92672>&gt;</span> sendEmailVerification() <span style=color:#f92672>=&gt;</span> _user.sendEmailVerification();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Finally, we could update theÂ <code>AuthRepository</code>Â class so that the relevant methods return the newÂ <code>AppUser</code>Â type (rather than theÂ <code>User</code>Â class from firebase_auth):</p><p>æœ€å¾Œï¼Œæˆ‘å€‘å¯ä»¥æ›´æ–° <code>AuthRepository</code> é¡ï¼Œè®“ç›¸é—œæ–¹æ³•è¿”å›æ–°çš„ <code>AppUser</code> é¡å‹ï¼ˆè€Œä¸æ˜¯ä¾†è‡ª <code>firebase_auth</code> çš„ <code>User</code> é¡ï¼‰ï¼š</p><pre tabindex=0><code>class AuthRepository {

  ... 

  Stream&lt;AppUser?&gt; authStateChanges() {
    return _auth.authStateChanges().map(_convertUser);
  }

  AppUser? get currentUser =&gt; _convertUser(_auth.currentUser);

  /// Helper method to convert a [User] to an [AppUser]
  AppUser? _convertUser(User? user) =&gt;
      user != null ? FirebaseAppUser(user) : null;
}
</code></pre><p>Here&rsquo;s a visual representation of what we have created:</p><p>ä»¥ä¸‹æ˜¯æˆ‘å€‘æ‰€å‰µå»ºå…§å®¹çš„åœ–ç¤ºï¼š</p><p><img alt="Abstracting away all details of the FirebaseAuth class behind an AuthRepository" loading=lazy src=https://codewithandrea.com/articles/abstraction-repository-pattern-flutter/images/presentation-data-layer-auth-repository.webp></p><p>With these changes, all implementation details from firebase_auth are abstracted away, and the calling code will only ever use types and classes thatÂ <strong>we have defined</strong>.</p><p>é€šéé€™äº›æ›´æ”¹ï¼Œæ‰€æœ‰ä¾†è‡ª <code>firebase_auth</code> çš„å¯¦ç¾ç´°ç¯€éƒ½è¢«æŠ½è±¡æ‰äº†ï¼Œèª¿ç”¨ä»£ç¢¼åªæœƒä½¿ç”¨<strong>æˆ‘å€‘è‡ªå·±å®šç¾©çš„é¡å‹å’Œé¡</strong>ã€‚</p><p>For example, the code for sending a verification email inside a button callback would look like this:</p><p>ä¾‹å¦‚ï¼Œåœ¨æŒ‰éˆ•å›èª¿ä¸­ç™¼é€é©—è­‰éƒµä»¶çš„ä»£ç¢¼å°‡å¦‚ä¸‹æ‰€ç¤ºï¼š</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dart data-lang=dart><span style=display:flex><span>onPressed: () <span style=color:#f92672>=&gt;</span> ref.read(authRepositoryProvider)
</span></span><span style=display:flex><span>    .currentUser<span style=color:#f92672>!</span>
</span></span><span style=display:flex><span>    .sendEmailVerification();
</span></span></code></pre></div><p>Once again: since we&rsquo;re not talking to theÂ <code>FirebaseAuth</code>Â APIs directly, the UI code no longer depends on the firebase_auth package.</p><p>å†æ¬¡å¼·èª¿ï¼šç”±æ–¼æˆ‘å€‘ä¸å†ç›´æ¥èˆ‡ <code>FirebaseAuth</code> API äº¤äº’ï¼ŒUI ä»£ç¢¼ä¸å†ä¾è³´æ–¼ <code>firebase_auth</code> å¥—ä»¶ã€‚</p><hr><p>But what about testing?</p><p>ä½†æ¸¬è©¦å‘¢ï¼Ÿ</p><h3 id=testing-with-the-authrepository-class>Testing with the AuthRepository class<a hidden class=anchor aria-hidden=true href=#testing-with-the-authrepository-class>#</a></h3><p>Like weâ€™ve done in the previous example, we could ask ourselves how to mock theÂ <code>AuthRepository</code>Â class so that we can stub its methods and write tests using them.</p><p>å¦‚åŒä¹‹å‰çš„ä¾‹å­ï¼Œæˆ‘å€‘å¯ä»¥æ€è€ƒå¦‚ä½• mock <code>AuthRepository</code> é¡ï¼Œä»¥ä¾¿èƒ½å¤  stub å®ƒçš„æ–¹æ³•ä¸¦ç·¨å¯«æ¸¬è©¦ã€‚</p><p>I wonâ€™t go into all the details. But suffice it to say that we have the same problem as before: we canâ€™t create instances of theÂ <code>User</code>Â class because - just like theÂ <code>Query</code>Â class - itâ€™s not meant to be mocked.</p><p>é€™è£¡å°±ä¸è©³ç´°å±•é–‹äº†ï¼Œä½†å¯ä»¥è‚¯å®šçš„æ˜¯ï¼Œæˆ‘å€‘é¢è‡¨èˆ‡ä¹‹å‰ç›¸åŒçš„å•é¡Œï¼šæˆ‘å€‘ç„¡æ³•å‰µå»º <code>User</code> é¡çš„å¯¦ä¾‹ï¼Œå› ç‚ºå°±åƒ <code>Query</code> é¡ä¸€æ¨£ï¼Œå®ƒä¸¦ä¸æ˜¯ç‚ºäº† mock è€Œè¨­è¨ˆçš„ã€‚</p><p>Instead, the right approach is to use composition, which is exactly what we have done by creating a wrapperÂ <code>FirebaseAppUser</code>Â class (along with a baseÂ <code>AppUser</code>Â abstract class). This makes it much easier to write mocks without worrying about all the (complex) implementation details of theÂ <code>User</code>Â class.</p><p>æ­£ç¢ºçš„æ–¹æ³•æ˜¯ä½¿ç”¨<strong>çµ„åˆæ¨¡å¼</strong>ï¼Œé€™æ­£æ˜¯æˆ‘å€‘é€éå‰µå»º <code>FirebaseAppUser</code> åŒ…è£å™¨é¡ï¼ˆä»¥åŠåŸºç¤çš„ <code>AppUser</code> æŠ½è±¡é¡ï¼‰æ‰€åšçš„äº‹æƒ…ã€‚é€™è®“æˆ‘å€‘èƒ½æ›´è¼•é¬†åœ°ç·¨å¯« mockï¼Œè€Œä¸å¿…æ“”å¿ƒ <code>User</code> é¡çš„æ‰€æœ‰ï¼ˆè¤‡é›œï¼‰å¯¦ç¾ç´°ç¯€ã€‚</p><hr><p>In summary, weâ€™ve learned how to design domain-specific APIs (such asÂ <code>AuthRepository</code>Â andÂ <code>AppUser</code>) that only expose the functionality we need while ensuring that the rest of the code doesnâ€™t depend on 3rd party APIs (<code>FirebaseAuth</code>Â andÂ <code>User</code>Â from the firebase_auth package).</p><p>æˆ‘å€‘å­¸ç¿’äº†å¦‚ä½•è¨­è¨ˆç‰¹å®šæ–¼é ˜åŸŸçš„ APIï¼ˆä¾‹å¦‚ <code>AuthRepository</code> å’Œ <code>AppUser</code>ï¼‰ï¼Œé€™äº› API åªæš´éœ²æˆ‘å€‘éœ€è¦çš„åŠŸèƒ½ï¼Œä¸¦ç¢ºä¿å…¶é¤˜ä»£ç¢¼ä¸ä¾è³´ç¬¬ä¸‰æ–¹ APIï¼ˆä¾‹å¦‚ <code>firebase_auth</code> å¥—ä»¶ä¸­çš„ <code>FirebaseAuth</code> å’Œ <code>User</code>ï¼‰ã€‚</p><p>Without a doubt, this extra level of indirection forces us to write more code (that needs to be maintained and understood by other developers). And for small projects, it may not be worthwhile.</p><p>æ¯«ç„¡ç–‘å•ï¼Œé€™ä¸€é¡å¤–çš„é–“æ¥å±¤æ¬¡è¿«ä½¿æˆ‘å€‘ç·¨å¯«æ›´å¤šä»£ç¢¼ï¼ˆéœ€è¦å…¶ä»–é–‹ç™¼è€…ç†è§£å’Œç¶­è­·ï¼‰ã€‚å°æ–¼å°å‹é …ç›®ä¾†èªªï¼Œé€™å¯èƒ½ä¸å€¼å¾—ã€‚</p><p>But it also makes testing easier, and this is valuable further down the line (or if you have bigger projects).</p><p>ä½†é€™ä¹Ÿè®“æ¸¬è©¦è®Šå¾—æ›´åŠ ç°¡å–®ï¼Œè€Œé€™åœ¨å¾ŒæœŸï¼ˆæˆ–å°æ–¼å¤§å‹é …ç›®ï¼‰éå¸¸æœ‰åƒ¹å€¼ã€‚</p><p>With this knowledge, letâ€™s take a look at one last example. ğŸ‘‡</p><p>äº†è§£äº†é€™äº›ï¼Œæˆ‘å€‘ä¾†çœ‹çœ‹æœ€å¾Œä¸€å€‹ä¾‹å­ğŸ‘‡ã€‚</p><h2 id=example-transactions-in-firestore>Example: Transactions in Firestore<a hidden class=anchor aria-hidden=true href=#example-transactions-in-firestore>#</a></h2><p>A common feature in many modern databases is the ability to executeÂ <a href=https://firebase.google.com/docs/firestore/manage-data/transactions>transactions or batched writes</a>.</p><p>è¨±å¤šç¾ä»£æ•¸æ“šåº«çš„ä¸€å€‹å¸¸è¦‹åŠŸèƒ½æ˜¯åŸ·è¡Œ<a href=https://firebase.google.com/docs/firestore/manage-data/transactions>äº¤æ˜“æˆ–æ‰¹é‡å¯«å…¥</a>ã€‚</p><p>For example, suppose we wanted to implement a method that withdraws money from a bank account, but only if there are available funds.</p><p>ä¾‹å¦‚ï¼Œå‡è¨­æˆ‘å€‘å¸Œæœ›å¯¦ç¾ä¸€å€‹æ–¹æ³•ä¾†å¾éŠ€è¡Œå¸³æˆ¶ææ¬¾ï¼Œä½†åªæœ‰åœ¨æœ‰è¶³å¤ è³‡é‡‘æ™‚æ‰é€²è¡Œæ“ä½œã€‚</p><p>To avoid race conditions (e.g. two withdrawals happening at the same time), we may implement this using aÂ <strong>transaction</strong>:</p><p>ç‚ºäº†é¿å…ç«¶æ…‹æ¢ä»¶ï¼ˆä¾‹å¦‚åŒæ™‚é€²è¡Œçš„å…©æ¬¡ææ¬¾ï¼‰ï¼Œæˆ‘å€‘å¯ä»¥ä½¿ç”¨<strong>äº¤æ˜“</strong>ä¾†å¯¦ç¾ï¼š</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dart data-lang=dart><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>BankBalanceRepository</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> BankBalanceRepository(<span style=color:#66d9ef>this</span>._firestore);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>final</span> FirebaseFirestore _firestore;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  Future<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>void</span><span style=color:#f92672>&gt;</span> withdraw(<span style=color:#66d9ef>String</span> uid, <span style=color:#66d9ef>double</span> amount) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> _firestore.runTransaction((transaction) <span style=color:#66d9ef>async</span> {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>final</span> accountRef <span style=color:#f92672>=</span> _firestore.doc(<span style=color:#e6db74>&#39;accounts/</span><span style=color:#e6db74>$</span>uid<span style=color:#e6db74>&#39;</span>);
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>final</span> snapshot <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> transaction.<span style=color:#66d9ef>get</span>(accountRef);
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>final</span> balance <span style=color:#f92672>=</span> snapshot.<span style=color:#66d9ef>get</span>(<span style=color:#e6db74>&#39;balance&#39;</span>);
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (balance <span style=color:#f92672>&gt;</span> amount) {
</span></span><span style=display:flex><span>        transaction.update(accountRef, {<span style=color:#e6db74>&#39;balance&#39;</span><span style=color:#f92672>:</span> balance <span style=color:#f92672>&gt;</span> amount});
</span></span><span style=display:flex><span>      } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throw</span> StateError(<span style=color:#e6db74>&#39;Not enough funds&#39;</span>);
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>In this case, the public interface of theÂ <code>BankBalanceRepository</code>Â doesnâ€™t leak any Firestore-specific types.</p><p>åœ¨é€™å€‹ä¾‹å­ä¸­ï¼Œ<code>BankBalanceRepository</code> çš„å…¬å…±ä»‹é¢ä¸æœƒæ´©éœ²ä»»ä½•èˆ‡ Firestore ç›¸é—œçš„é¡å‹ã€‚</p><p>But what if we need to call multiple methods that are defined in separate repositories and run all the code inside a single transaction?</p><p>ä½†æ˜¯ï¼Œå¦‚æœæˆ‘å€‘éœ€è¦èª¿ç”¨å¤šå€‹å®šç¾©åœ¨ä¸åŒå­˜å„²åº«ä¸­çš„æ–¹æ³•ï¼Œä¸¦å°‡æ‰€æœ‰ä»£ç¢¼éƒ½æ”¾åœ¨ä¸€å€‹å–®ä¸€çš„äº¤æ˜“ä¸­åŸ·è¡Œï¼Œè©²æ€éº¼è¾¦ï¼Ÿ</p><p>Should we try to somehow mimic the Firestore transaction APIs by creating our own wrappers?</p><p>æˆ‘å€‘æ˜¯å¦æ‡‰è©²å˜—è©¦æ¨¡æ“¬ Firestore çš„äº¤æ˜“ APIï¼Œå‰µå»ºè‡ªå·±çš„åŒ…è£å™¨ï¼Ÿ</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dart data-lang=dart><span style=display:flex><span><span style=color:#75715e>// a wrapper class for running Cloud Firestore transactions
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>FirestoreTransaction</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> FirestoreTransaction(<span style=color:#66d9ef>this</span>._firestore);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>final</span> FirebaseFirestore _firestore;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// a wrapper for the [runTransaction] method
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// strictly speaking, we should write a wrapper for [TransactionHandler] too
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  Future<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> runTransaction<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span>(TransactionHandler<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> transactionHandler) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> _firestore.runTransaction(transactionHandler);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This kind of abstraction quickly takes us down a rabbit hole, and Iâ€™d argue that itâ€™s overkill.</p><p>é€™é¡æŠ½è±¡å¾ˆå®¹æ˜“è®“æˆ‘å€‘é™·å…¥éæ–¼è¤‡é›œçš„å¢ƒåœ°ï¼Œè€Œæˆ‘èªç‚ºé€™æ˜¯æ²’æœ‰å¿…è¦çš„ã€‚</p><p>Instead, it may be best to keep things simple by bringing all the logic inside a single method (such as theÂ <code>withdraw</code>Â method above) that doesnâ€™t leak any Firestore-specific APIs to the outside.</p><p>ç›¸åï¼Œæœ€å¥½ä¿æŒç°¡å–®ï¼Œå°‡æ‰€æœ‰é‚è¼¯æ”¾åœ¨å–®ä¸€æ–¹æ³•ä¸­ï¼ˆä¾‹å¦‚ä¸Šé¢çš„ <code>withdraw</code> æ–¹æ³•ï¼‰ï¼Œè€Œä¸å‘å¤–éƒ¨æ´©éœ²ä»»ä½•èˆ‡ Firestore ç›¸é—œçš„ APIã€‚</p><h2 id=warning-against-lowest-common-denominator-api-design>Warning against â€œlowest common denominatorâ€ API design<a hidden class=anchor aria-hidden=true href=#warning-against-lowest-common-denominator-api-design>#</a></h2><p>Initially, we set out on a quest to discover how to write backend-agnostic APIs.</p><p>æœ€åˆï¼Œæˆ‘å€‘è©¦åœ–æ¢ç´¢å¦‚ä½•ç·¨å¯«èˆ‡å¾Œç«¯ç„¡é—œçš„ APIã€‚</p><p>Along the way, weâ€™ve learned how to write repositories that encapsulate the implementation details of 3rd party APIs.</p><p>åœ¨éç¨‹ä¸­ï¼Œæˆ‘å€‘å­¸æœƒäº†å¦‚ä½•ç·¨å¯«å°è£ç¬¬ä¸‰æ–¹ API å¯¦ç¾ç´°ç¯€çš„å­˜å„²åº«ã€‚</p><p>Weâ€™ve also seen that some abstractions can â€œleakâ€ external types (such as theÂ <code>itemsQuery()</code>Â method that returns aÂ <code>Query&lt;Item></code>):</p><p>æˆ‘å€‘ä¹Ÿçœ‹åˆ°æŸäº›æŠ½è±¡æœƒã€Œæ´©éœ²ã€å¤–éƒ¨é¡å‹ï¼ˆä¾‹å¦‚è¿”å› <code>Query&lt;Item></code> çš„ <code>itemsQuery()</code> æ–¹æ³•ï¼‰ï¼š</p><p><img alt="A basic abstraction that separates the presentation and data layers (backend-specific)" loading=lazy src=https://codewithandrea.com/articles/abstraction-repository-pattern-flutter/images/presentation-data-layer-query.webp></p><p>And we said that if we really wanted to, we could have replacedÂ <code>Query&lt;T></code>Â withÂ <code>Stream&lt;List&lt;T>></code>. But in doing so, we ended up with a less powerful API that doesnâ€™t support pagination:</p><p>æˆ‘å€‘æåˆ°ï¼Œå¦‚æœçœŸçš„éœ€è¦ï¼Œå¯ä»¥å°‡ <code>Query&lt;T></code> æ›¿æ›ç‚º <code>Stream&lt;List&lt;T>></code>ã€‚ä½†é€™éº¼åšæœƒå°è‡´ä¸€å€‹ä¸å¤ å¼·å¤§çš„ APIï¼Œå› ç‚ºå®ƒä¸æ”¯æŒåˆ†é ï¼š</p><p><img alt="Updated implementation: the presentation layer is now backend-agnostic as it no longer depends on the Query type" loading=lazy src=https://codewithandrea.com/articles/abstraction-repository-pattern-flutter/images/presentation-data-layer-stream.webp></p><p>Indeed, designing APIs with abstraction in mind can lead to the â€œlowest common denominatorâ€ syndrome.</p><p>å¯¦éš›ä¸Šï¼Œå°ˆæ³¨æ–¼æŠ½è±¡è¨­è¨ˆ API å¯èƒ½æœƒå°è‡´ã€Œæœ€ä½å…¬åˆ†æ¯ã€çš„å•é¡Œã€‚</p><p>In other words, by writing backend-agnostic code, we risk creating APIs that are too generic and canâ€™t make the most of what our backend has to offer.</p><p>æ›å¥è©±èªªï¼Œé€éç·¨å¯«èˆ‡å¾Œç«¯ç„¡é—œçš„ä»£ç¢¼ï¼Œæˆ‘å€‘å¯èƒ½å‰µå»ºå‡ºéæ–¼é€šç”¨çš„ APIï¼Œç„¡æ³•å……åˆ†åˆ©ç”¨å¾Œç«¯çš„ç‰¹æ€§ã€‚</p><p>For example, Cloud Firestore offers features such asÂ <strong>realtime listeners</strong>,Â <strong>caching</strong>,Â <strong>transactions</strong>, andÂ <strong>offline mode</strong>.</p><p>ä¾‹å¦‚ï¼ŒCloud Firestore æä¾›äº†<strong>å¯¦æ™‚ç›£è½</strong>ã€<strong>ç·©å­˜</strong>ã€<strong>äº¤æ˜“</strong>å’Œ<strong>é›¢ç·šæ¨¡å¼</strong>ç­‰åŠŸèƒ½ã€‚</p><p>On the other hand, a simple REST API gives you only one feature: the ability to make a request and get a response (as a one-time read).</p><p>å¦ä¸€æ–¹é¢ï¼Œä¸€å€‹ç°¡å–®çš„ REST API åªæä¾›ä¸€å€‹åŠŸèƒ½ï¼šç™¼é€è«‹æ±‚ä¸¦ç²å–éŸ¿æ‡‰ï¼ˆåƒ…é™ä¸€æ¬¡æ€§è®€å–ï¼‰ã€‚</p><p>But it would be a mistake to write a Cloud Firestore wrapper that can only read data using futures (rather than streams or queries) because one day, weÂ <strong>might</strong>Â move to a REST API that doesnâ€™t support realtime listeners.</p><p>ä½†å¦‚æœæˆ‘å€‘å‡ºæ–¼æœªä¾†å¯èƒ½åˆ‡æ›åˆ°ä¸æ”¯æŒå¯¦æ™‚ç›£è½çš„ REST API è€Œç·¨å¯«åªèƒ½ä½¿ç”¨ futureï¼ˆè€Œä¸æ˜¯ stream æˆ– queryï¼‰è®€å–æ•¸æ“šçš„ Firestore åŒ…è£å™¨ï¼Œé‚£å°±éŒ¯äº†ã€‚</p><p>So try to design APIs thatÂ <strong>let you make the most</strong>Â of all the features your backend offersÂ <strong>today</strong>, and donâ€™t compromise functionality â€œfor the sake of abstractionâ€ or try to make your code â€œfuture-proofâ€.</p><p>æ‰€ä»¥ï¼Œè©¦è‘—è¨­è¨ˆ APIï¼Œ<strong>å……åˆ†åˆ©ç”¨å¾Œç«¯ç›®å‰æ‰€æä¾›çš„æ‰€æœ‰åŠŸèƒ½</strong>ï¼Œä¸è¦ç‚ºäº†ã€ŒæŠ½è±¡ã€è€Œå¦¥å”åŠŸèƒ½ï¼Œæˆ–è€…è©¦åœ–è®“ä»£ç¢¼ã€Œæœªä¾†-proofã€ã€‚</p><p><strong>Remember: abstraction is a tool, not a goal.</strong></p><p><strong>è¨˜ä½ï¼šæŠ½è±¡æ˜¯ä¸€ç¨®å·¥å…·ï¼Œè€Œä¸æ˜¯ç›®çš„ã€‚</strong></p><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>When building an app, itâ€™s important to use API design principles, design patterns, and app architecture to ensure your code is testable, scalable, and maintainable.</p><p>åœ¨æ§‹å»ºæ‡‰ç”¨æ™‚ï¼Œä½¿ç”¨ API è¨­è¨ˆåŸå‰‡ã€è¨­è¨ˆæ¨¡å¼å’Œæ‡‰ç”¨æ¶æ§‹ä¾†ç¢ºä¿ä»£ç¢¼å¯æ¸¬è©¦ã€å¯æ“´å±•å’Œå¯ç¶­è­·éå¸¸é‡è¦ã€‚</p><p>But these are all skills that you will acquire by practising over time.</p><p>ä½†é€™äº›éƒ½æ˜¯éœ€è¦é€šéæ™‚é–“ä¸æ–·ç·´ç¿’æ‰èƒ½æŒæ¡çš„æŠ€èƒ½ã€‚</p><p>Whether youâ€™re starting out or you have a few years of experience, remember this:Â <strong>donâ€™t overcomplicate things and keep it simple</strong>.</p><p>ç„¡è«–ä½ æ˜¯å‰›èµ·æ­¥é‚„æ˜¯å·²ç¶“æœ‰ä¸€äº›ç¶“é©—ï¼Œè«‹è¨˜ä½ï¼š<strong>ä¸è¦éæ–¼è¤‡é›œåŒ–ï¼Œä¿æŒç°¡å–®</strong>ã€‚</p><p>I hope this article has helped you build some intuition about when to use abstractions (and when not to), so you can make the right tradeoffs depending on what&rsquo;s most important to you.</p><p>å¸Œæœ›é€™ç¯‡æ–‡ç« èƒ½å¹«åŠ©ä½ å»ºç«‹å°æ–¼ä½•æ™‚ä½¿ç”¨æŠ½è±¡ï¼ˆä»¥åŠä½•æ™‚ä¸ä½¿ç”¨ï¼‰çš„ç›´è¦ºï¼Œè®“ä½ èƒ½æ ¹æ“šæœ€é‡è¦çš„éœ€æ±‚åšå‡ºæ­£ç¢ºçš„å–æ¨ã€‚</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://easylive1989.github.io/readings/tags/andrea-bizzotto/>Andrea Bizzotto</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://easylive1989.github.io/readings/>Readings</a></span> Â·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>