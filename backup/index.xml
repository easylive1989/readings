<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Backups on Readings</title><link>https://easylive1989.github.io/readings/backup/</link><description>Recent content in Backups on Readings</description><generator>Hugo -- 0.143.1</generator><language>en</language><lastBuildDate>Sat, 08 Feb 2025 00:00:28 +0800</lastBuildDate><atom:link href="https://easylive1989.github.io/readings/backup/index.xml" rel="self" type="application/rss+xml"/><item><title>One at a Time</title><link>https://easylive1989.github.io/readings/backup/one-at-a-time/</link><pubDate>Sat, 08 Feb 2025 00:00:28 +0800</pubDate><guid>https://easylive1989.github.io/readings/backup/one-at-a-time/</guid><description>&lt;p>&lt;a href="https://tidyfirst.substack.com/p/one-at-a-time">Source&lt;/a>&lt;/p>
&lt;p>Whatever principles I try to live &amp;amp; work by, I try to apply them just as much &amp;amp; as often as possible. Yesterday, though, a lawn chair taught me a valuable lesson about the principle of flow.&lt;/p>
&lt;p>無論我嘗試遵循什麼原則生活和工作，我都盡可能頻繁地應用這些原則。然而，昨天，一把lawn chair教會了我關於流動原則的寶貴一課。&lt;/p>
&lt;p>&lt;img loading="lazy" src="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F80858843-e71f-46e9-ae5e-e5b63ce43e2d_768x576.jpeg">&lt;/p>
&lt;p>The Principle of Flow states that, all else being equal, smaller batches of value more frequently is worth more than that same value delivered in fewer, larger batches. You’ll find the Principle of Flow working every corner of Extreme Programming—software design, planning, testing, integration, deployment, conversations—every corner.&lt;/p></description></item><item><title>Tdd Best Practices</title><link>https://easylive1989.github.io/readings/backup/tdd-best-practices/</link><pubDate>Fri, 07 Feb 2025 17:19:54 +0800</pubDate><guid>https://easylive1989.github.io/readings/backup/tdd-best-practices/</guid><description>&lt;p>&lt;a href="https://enterprisecraftsmanship.com/posts/tdd-best-practices/">Source&lt;/a>&lt;/p>
&lt;p>Last week, we discussed the differences between stubs and mocks. Today, we’ll talk about some general tips and advice that regard to TDD and writing tests in general.&lt;/p>
&lt;ul>
&lt;li>Test-induced design damage or why TDD is so painful&lt;/li>
&lt;li>How to do painless TDD&lt;/li>
&lt;li>Integration testing or how to sleep well at nights&lt;/li>
&lt;li>The most important TDD rule&lt;/li>
&lt;li>Stubs vs Mocks&lt;/li>
&lt;li>&lt;strong>TDD best practices&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h2 id="test-first-vs-code-first-approach">Test-first vs code-first approach&lt;/h2>
&lt;p>There’s some dispute about how exactly tests should be written. While the TDD process itself insists on the test-first approach, I personally think that both ways are applicable in different circumstances. Let’s look at the pros and cons of each of them.&lt;/p></description></item><item><title>Continuous Integration</title><link>https://easylive1989.github.io/readings/backup/continuous-integration/</link><pubDate>Fri, 07 Feb 2025 17:04:50 +0800</pubDate><guid>https://easylive1989.github.io/readings/backup/continuous-integration/</guid><description>&lt;p>&lt;a href="https://www.martinfowler.com/articles/continuousIntegration.html">Source&lt;/a>&lt;/p>
&lt;p>I vividly remember one of my first sightings of a large software project. I was taking a summer internship at a large English electronics company. My manager, part of the QA group, gave me a tour of a site and we entered a huge, depressing, windowless warehouse full of people working in cubicles. I was told that these programmers had been writing code for this software for a couple of years, and while they were done programming, their separate units were now being integrated together, and they had been integrating for several months. My guide told me that nobody really knew how long it would take to finish integrating. From this I learned a common story of software projects: integrating the work
of multiple developers is a long and unpredictable process.&lt;/p></description></item><item><title>Learning in the Forest</title><link>https://easylive1989.github.io/readings/backup/learning-in-the-forest/</link><pubDate>Fri, 07 Feb 2025 16:18:55 +0800</pubDate><guid>https://easylive1989.github.io/readings/backup/learning-in-the-forest/</guid><description>&lt;p>&lt;a href="https://tidyfirst.substack.com/p/learning-in-the-forest?utm_source=post-email-title&amp;amp;publication_id=256838&amp;amp;post_id=151741306&amp;amp;utm_campaign=email-post-title&amp;amp;isFreemail=true&amp;amp;r=qyvh0&amp;amp;triedRedirect=true&amp;amp;utm_medium=email">Source&lt;/a>&lt;/p>
&lt;p>How &amp;amp; why does The Forest emphasize learning over production?&lt;/p>
&lt;p>《森林》如何以及為什麼強調學習重於產出？&lt;/p>
&lt;p>&lt;img loading="lazy" src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F9c18a32f-0673-40ca-9cb1-5cd7ccc0561c_583x220.png">&lt;/p>
&lt;p>Well here you go, thrillfall.&lt;/p>
&lt;p>以下是詳細說明，thrillfall。&lt;/p>
&lt;p>Kent once visited a media tablet project that Dan Ingalls was running (pre-iPad). They were coding in Smalltalk, of course, but they had to port it to their new platform. He was telling me the story of implementing the graphics primitives. Dan had (with Diana Merry-Shapiro) invented BitBLT. Everybody on the team had implemented BitBLT on some platform. Everybody except one. So that person, of course, implemented BitBLT.&lt;/p></description></item><item><title>Cannot Mesure Productivity</title><link>https://easylive1989.github.io/readings/backup/cannot-mesure-productivity/</link><pubDate>Fri, 07 Feb 2025 16:17:38 +0800</pubDate><guid>https://easylive1989.github.io/readings/backup/cannot-mesure-productivity/</guid><description>&lt;p>&lt;a href="https://www.martinfowler.com/bliki/CannotMeasureProductivity.html">Source&lt;/a>&lt;/p>
&lt;p>We see so much emotional discussion about software process, design practices and the like. Many of these arguments are impossible to resolve because the software industry lacks the ability to measure some of the basic elements of the effectiveness of software development. In particular we have no way of reasonably measuring productivity.&lt;/p>
&lt;p>我們經常看到許多關於軟體流程、設計實踐等方面的情緒化討論。其中許多爭論無法解決，因為軟體產業缺乏衡量軟體開發有效性基本要素的能力。特別是，我們無法合理地衡量生產力。&lt;/p>
&lt;p>Productivity, of course, is something you determine by looking at the input of an activity and its output. So to measure software productivity you have to measure the output of software development - the reason we can&amp;rsquo;t measure productivity is because we can&amp;rsquo;t measure output.&lt;/p></description></item><item><title>Bounded Context</title><link>https://easylive1989.github.io/readings/backup/bounded-context/</link><pubDate>Fri, 07 Feb 2025 15:33:58 +0800</pubDate><guid>https://easylive1989.github.io/readings/backup/bounded-context/</guid><description>&lt;p>&lt;a href="https://martinfowler.com/bliki/BoundedContext.html">Source&lt;/a>&lt;/p>
&lt;p>Bounded Context is a central pattern in Domain-Driven Design. It is the focus of DDD&amp;rsquo;s strategic design section which is all about dealing with large models and teams. DDD deals with large models by dividing them into different Bounded Contexts and being explicit about their interrelationships.&lt;/p>
&lt;p>限界上下文（Bounded Context）是領域驅動設計（Domain-Driven Design, DDD）的核心模式。它是 DDD 戰略設計部分的焦點，主要處理大型模型和團隊。DDD 通過將大型模型劃分為不同的限界上下文，並明確定義它們之間的相互關係，來管理這些龐大的模型。&lt;/p>
&lt;p>&lt;img loading="lazy" src="https://martinfowler.com/bliki/images/boundedContext/sketch.png">&lt;/p>
&lt;p>DDD is about designing software based on models of the underlying domain. A model acts as a &lt;a href="https://martinfowler.com/bliki/UbiquitousLanguage.html">UbiquitousLanguage&lt;/a> to help communication between software developers and domain experts. It also acts as the conceptual foundation for the design of the software itself - how it&amp;rsquo;s broken down into objects or functions. To be effective, a model needs to be unified - that is to be internally consistent so that there are no contradictions within it.&lt;/p></description></item></channel></rss>