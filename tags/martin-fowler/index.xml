<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Martin Fowler on Readings</title><link>https://easylive1989.github.io/readings/tags/martin-fowler/</link><description>Recent content in Martin Fowler on Readings</description><generator>Hugo -- 0.144.2</generator><language>en</language><lastBuildDate>Sat, 22 Feb 2025 11:00:10 +0800</lastBuildDate><atom:link href="https://easylive1989.github.io/readings/tags/martin-fowler/index.xml" rel="self" type="application/rss+xml"/><item><title>It's Not Just Standing Up Patterns for Daily Standup Meetings</title><link>https://easylive1989.github.io/readings/backup/its-not-just-standing-up-patterns-for-daily-standup-meetings/</link><pubDate>Sat, 22 Feb 2025 11:00:10 +0800</pubDate><guid>https://easylive1989.github.io/readings/backup/its-not-just-standing-up-patterns-for-daily-standup-meetings/</guid><description>&lt;p>&lt;a href="https://martinfowler.com/articles/itsNotJustStandingUp.html">Source&lt;/a>&lt;/p>
&lt;p>&lt;em>Daily stand-up meetings have become a common ritual of many teams, especially in Agile software development. However, there are many subtle details that distinguish effective stand-ups and a waste of time.&lt;/em>&lt;/p>
&lt;p>每日站立會議已成為許多團隊的常見儀式，尤其是在敏捷軟體開發中。然而，存在許多細微的細節，區分了有效的站立會議和浪費時間的會議。&lt;/p>
&lt;h2 id="we-stand-up-to-keep-the-meeting-short">We stand up to keep the meeting short&lt;/h2>
&lt;p>The daily stand-up meeting (also known as a “daily scrum”, a “daily huddle”, “morning roll-call”, etc.) is simple to describe:&lt;/p>
&lt;p>每日站立會議（也稱為“每日 Scrum”、“每日聚集”、“早點名”等）很容易描述：&lt;/p>
&lt;p>&lt;em>The whole team meets every day for a quick status update. We stand up to keep the meeting short.&lt;/em>&lt;/p></description></item><item><title>On Pair Programming</title><link>https://easylive1989.github.io/readings/backup/on-pair-programming/</link><pubDate>Sat, 22 Feb 2025 10:59:12 +0800</pubDate><guid>https://easylive1989.github.io/readings/backup/on-pair-programming/</guid><description>&lt;p>&lt;a href="https://martinfowler.com/articles/on-pair-programming.html">Source&lt;/a>&lt;/p>
&lt;blockquote>
&lt;p>Betty Snyder and I, from the beginning, were a pair. And I believe that the best programs and designs are done by pairs, because you can criticise each other, and find each others errors, and use the best ideas.
&amp;ndash; &lt;a href="http://www.computerhistory.org/revolution/birth-of-the-computer/4/78/2258">Jean Bartik, one of the very first programmers&lt;/a>&lt;/p>
&lt;p>從一開始，Betty Snyder 和我就是一對。我相信最好的程式和設計都是由兩人合作完成的，因為這樣可以互相批評、找出彼此的錯誤，並採用最好的點子。
—— &lt;a href="http://www.computerhistory.org/revolution/birth-of-the-computer/4/78/2258">Jean Bartik，最早的程式設計師之一&lt;/a>&lt;/p>&lt;/blockquote>
&lt;blockquote>
&lt;p>Write all production programs with two people sitting at one machine.
&amp;ndash; &lt;a href="https://www.amazon.com/gp/product/0321278658/ref=as_li_tl?ie=UTF8&amp;amp;camp=1789&amp;amp;creative=9325&amp;amp;creativeASIN=0321278658&amp;amp;linkCode=as2&amp;amp;tag=martinfowlerc-20">Kent Beck&lt;/a>
所有正式的生產程式都應該由兩個人坐在同一台機器前一起編寫。
—— &lt;a href="https://www.amazon.com/gp/product/0321278658/ref=as_li_tl?ie=UTF8&amp;amp;camp=1789&amp;amp;creative=9325&amp;amp;creativeASIN=0321278658&amp;amp;linkCode=as2&amp;amp;tag=martinfowlerc-20">Kent Beck&lt;/a>&lt;/p></description></item><item><title>YAGNI</title><link>https://easylive1989.github.io/readings/backup/yagni/</link><pubDate>Mon, 17 Feb 2025 13:21:44 +0800</pubDate><guid>https://easylive1989.github.io/readings/backup/yagni/</guid><description>&lt;p>&lt;a href="https://martinfowler.com/bliki/Yagni.html">Source&lt;/a>&lt;/p>
&lt;p>Yagni originally is an acronym that stands for “You Aren&amp;rsquo;t Gonna Need It”. It is a mantra from &lt;a href="https://martinfowler.com/bliki/ExtremeProgramming.html">ExtremeProgramming&lt;/a> that&amp;rsquo;s often used generally in agile software teams. It&amp;rsquo;s a statement that some capability we presume our software needs in the future should not be built now because “you aren&amp;rsquo;t gonna need it”.&lt;/p>
&lt;p>Yagni 最初是「You Aren&amp;rsquo;t Gonna Need It」（你不會需要它）的縮寫。這是一個來自&lt;a href="https://martinfowler.com/bliki/ExtremeProgramming.html">極限編程（Extreme Programming, XP）&lt;/a>的口號，在敏捷開發團隊中經常被廣泛使用。它的核心理念是，我們假設軟體未來可能需要某種功能，但現在不應該提前開發，因為「你不會需要它」。&lt;/p>
&lt;p>Yagni is a way to refer to the XP practice of Simple Design (from the first edition of &lt;a href="https://www.amazon.com/gp/product/0321278658/ref=as_li_tl?ie=UTF8&amp;amp;camp=1789&amp;amp;creative=9325&amp;amp;creativeASIN=0321278658&amp;amp;linkCode=as2&amp;amp;tag=martinfowlerc-20">The White Book&lt;/a>, the second edition refers to the related notion of “incremental design”). 1 Like many elements of XP, it&amp;rsquo;s a sharp contrast to elements of the widely held principles of software engineering in the late 90s. At that time there was a big push for careful up-front planning of software development.&lt;/p></description></item><item><title>Keystone Interface</title><link>https://easylive1989.github.io/readings/backup/keystone-interface/</link><pubDate>Mon, 17 Feb 2025 13:21:05 +0800</pubDate><guid>https://easylive1989.github.io/readings/backup/keystone-interface/</guid><description>&lt;p>&lt;a href="https://martinfowler.com/bliki/KeystoneInterface.html">Source&lt;/a>&lt;/p>
&lt;p>Software development teams find life can be much easier if they integrate their work as often as they can. They also find it valuable to release frequently into production. But teams don&amp;rsquo;t want to expose half-developed features to their users. A useful technique to deal with this tension is to build all the back-end code, integrate, but don&amp;rsquo;t build the user-interface. The feature can be integrated and tested, but the UI is held back until the end until, like a keystone, it&amp;rsquo;s added to complete the feature, revealing it to the users.&lt;/p></description></item><item><title>Is Design Dead</title><link>https://easylive1989.github.io/readings/backup/is-design-dead/</link><pubDate>Sat, 08 Feb 2025 21:39:18 +0800</pubDate><guid>https://easylive1989.github.io/readings/backup/is-design-dead/</guid><description>&lt;p>&lt;a href="https://martinfowler.com/articles/designDead.html">Source&lt;/a>&lt;/p>
&lt;p>&lt;a href="http://www.extremeprogramming.org/">Extreme Programming&lt;/a> (XP) challenges many of the common assumptions about software development. Of these one of the most controversial is its rejection of significant effort in up-front design, in favor of a more evolutionary approach. To its detractors this is a return to “code and fix” development - usually derided as hacking. To its fans it is often seen as a rejection of design techniques (such as the UML), principles and patterns. Don&amp;rsquo;t worry about design, if you listen to your code a good design will appear.&lt;/p></description></item><item><title>Gui Architectures</title><link>https://easylive1989.github.io/readings/backup/gui-architectures/</link><pubDate>Sat, 08 Feb 2025 21:37:55 +0800</pubDate><guid>https://easylive1989.github.io/readings/backup/gui-architectures/</guid><description>&lt;p>&lt;a href="https://martinfowler.com/eaaDev/uiArchs.html">Source&lt;/a>&lt;/p>
&lt;p>&lt;em>Graphical User Interfaces provide a rich interaction between the user and a software system. Such richness is complex to manage, so it&amp;rsquo;s important to contain that complexity with a thoughtful architecture. The Forms and Controls pattern works well for systems with a simple flow, but as it breaks down under the weight of greater complexity, most people turn to “Model-View-Controller” (MVC). Sadly MVC is one of the most misunderstood architectural patterns around, and systems using that name display a range of important differences, sometimes described under names like Application Model, Model-View-Presenter, Presentation Model, MVVM, and the like. The best way to think of MVC is as set of principles including the separation of presentation from domain logic and synchronizing presentation state through events (the observer pattern).&lt;/em>&lt;/p></description></item><item><title>Cannot Measure Productivity</title><link>https://easylive1989.github.io/readings/backup/cannot-measure-productivity/</link><pubDate>Sat, 08 Feb 2025 21:36:49 +0800</pubDate><guid>https://easylive1989.github.io/readings/backup/cannot-measure-productivity/</guid><description>&lt;p>&lt;a href="https://www.martinfowler.com/bliki/CannotMeasureProductivity.html">Source&lt;/a>&lt;/p>
&lt;p>We see so much emotional discussion about software process, design practices and the like. Many of these arguments are impossible to resolve because the software industry lacks the ability to measure some of the basic elements of the effectiveness of software development. In particular we have no way of reasonably measuring productivity.&lt;/p>
&lt;p>我們經常看到許多關於軟體流程、設計實踐等方面的情緒化討論。其中許多爭論無法解決，因為軟體產業缺乏衡量軟體開發有效性基本要素的能力。特別是，我們無法合理地衡量生產力。&lt;/p>
&lt;p>Productivity, of course, is something you determine by looking at the input of an activity and its output. So to measure software productivity you have to measure the output of software development - the reason we can&amp;rsquo;t measure productivity is because we can&amp;rsquo;t measure output.&lt;/p></description></item><item><title>CQRS</title><link>https://easylive1989.github.io/readings/backup/cqrs/</link><pubDate>Sat, 08 Feb 2025 21:36:02 +0800</pubDate><guid>https://easylive1989.github.io/readings/backup/cqrs/</guid><description>&lt;p>&lt;a href="https://martinfowler.com/bliki/CQRS.html">Source&lt;/a>&lt;/p>
&lt;p>CQRS stands for &lt;strong>Command Query Responsibility Segregation&lt;/strong>. It&amp;rsquo;s a pattern that I first heard described by &lt;a href="https://twitter.com/gregyoung">Greg Young&lt;/a>. At its heart is the notion that you can use a different model to update information than the model you use to read information. For some situations, this separation can be valuable, but beware that for most systems CQRS adds risky complexity.&lt;/p>
&lt;p>CQRS 代表命令查詢責任分離（Command Query Responsibility Segregation）。這是一種由 Greg Young 首次描述的設計模式。其核心理念是，更新資料時可以使用一種模型，而讀取資料時可以使用另一種模型。在某些情況下，這種分離可能非常有價值，但要注意，對於大多數系統而言，CQRS 可能會增加不必要的複雜性和風險。&lt;/p>
&lt;p>The mainstream approach people use for interacting with an information system is to treat it as a CRUD datastore. By this I mean that we have mental model of some record structure where we can &lt;strong>c&lt;/strong>reate new records, &lt;strong>r&lt;/strong>ead records, &lt;strong>u&lt;/strong>pdate existing records, and &lt;strong>d&lt;/strong>elete records when we&amp;rsquo;re done with them. In the simplest case, our interactions are all about storing and retrieving these records.&lt;/p></description></item><item><title>Forest and Desert</title><link>https://easylive1989.github.io/readings/backup/forest-and-desert-martin/</link><pubDate>Sat, 08 Feb 2025 21:34:54 +0800</pubDate><guid>https://easylive1989.github.io/readings/backup/forest-and-desert-martin/</guid><description>&lt;p>&lt;a href="https://martinfowler.com/bliki/ForestAndDesert.html">Source&lt;/a>&lt;/p>
&lt;p>The Forest and the Desert is a metaphor for thinking about software development processes, developed by Beth Andres-Beck and hir father Kent Beck. It posits that two communities of software developers have great difficulty communicating to each other because they live in very different contexts, so advice that applies to one sounds like nonsense to the other.&lt;/p>
&lt;p>《森林與沙漠》是一個用來思考軟體開發流程的隱喻，由 Beth Andres-Beck 與其父 Kent Beck 提出。這個隱喻認為，兩種軟體開發者社群之間的溝通困難重重，因為他們所處的環境截然不同，因此適用於其中一方的建議，對另一方而言往往顯得荒謬無稽。&lt;/p>
&lt;p>The desert is the common world of software development, where bugs are plentiful, skill isn&amp;rsquo;t cultivated, and communications with users is difficult. The forest is the world of a well-run team that uses something like &lt;a href="https://martinfowler.com/bliki/ExtremeProgramming.html">Extreme Programming&lt;/a>, where developers swiftly put changes into production, protected by their tests, code is invested in to keep it healthy, and there is regular contact with The Customer.&lt;/p></description></item><item><title>Is Tdd Dead</title><link>https://easylive1989.github.io/readings/backup/is-tdd-dead/</link><pubDate>Sat, 08 Feb 2025 15:52:56 +0800</pubDate><guid>https://easylive1989.github.io/readings/backup/is-tdd-dead/</guid><description>&lt;p>&lt;a href="https://martinfowler.com/articles/is-tdd-dead/">Source&lt;/a>&lt;/p>
&lt;h2 id="where-this-came-from">Where This Came From&lt;/h2>
&lt;p>This conversation began as a consequence to &lt;a href="http://david.heinemeierhansson.com/2014/tdd-is-dead-long-live-testing.html">David’s RailsConf keynote&lt;/a> where he expressed his unhappiness with TDD and Unit Testing in the Rails community. He shortly followed this with some blog posts, the first of which declared that &lt;a href="http://david.heinemeierhansson.com/2014/tdd-is-dead-long-live-testing.html">“TDD is dead”&lt;/a>.&lt;/p>
&lt;p>這段對話始於 David 在 RailsConf 的主題演講中表達了他對 Rails 社區中 TDD 和單元測試的不滿。隨後不久,他發表了一些博客文章,其中第一篇宣稱「TDD 已死」。&lt;/p>
&lt;p>A couple of days after this, I sent him a typo correction to a follow-on post, and he said he’d welcome my thoughts on his talk and blog post. We then had an enjoyable and thoughtful discussion for an hour on Skype. David had a similar discussion with Kent, and Kent suggested that we continue the discussion with all three of us, and make the conversation public. David tweeted the idea and got a lot of positive reactions.&lt;/p></description></item><item><title>Mocks Arent Stubs</title><link>https://easylive1989.github.io/readings/backup/mocks-arent-stubs/</link><pubDate>Sat, 08 Feb 2025 09:28:05 +0800</pubDate><guid>https://easylive1989.github.io/readings/backup/mocks-arent-stubs/</guid><description>&lt;p>&lt;a href="https://martinfowler.com/articles/mocksArentStubs.html">Source&lt;/a>&lt;/p>
&lt;p>The term &amp;lsquo;Mock Objects&amp;rsquo; has become a popular one to describe special case objects that mimic real objects for testing. Most language environments now have frameworks that make it easy to create mock objects. What&amp;rsquo;s often not realized, however, is that mock objects are but one form of special case test object, one that enables a different style of testing. In this article I&amp;rsquo;ll explain how mock objects work, how they encourage testing based on behavior verification, and how the community around them uses them to develop a different style of testing.&lt;/p></description></item><item><title>Test Cancer</title><link>https://easylive1989.github.io/readings/backup/test-cancer/</link><pubDate>Sat, 08 Feb 2025 09:26:48 +0800</pubDate><guid>https://easylive1989.github.io/readings/backup/test-cancer/</guid><description>&lt;p>&lt;a href="https://martinfowler.com/bliki/TestCancer.html">Source&lt;/a>&lt;/p>
&lt;p>As my career has turned into full-time authorship, I often worry about distancing myself from the realities of day-to-day software development. I&amp;rsquo;ve seen other well-known figures lose contact with reality, and I fear the same fate. My greatest source of resistance to this is Thoughtworks, which acts as a regular dose of reality to keep my feet on the ground.&lt;/p>
&lt;p>隨著我的職業生涯逐漸轉向全職作者,我經常擔心自己會脫離日常軟體開發的現實。我見過其他知名人物失去與現實的聯繫,而我也擔心自己會面臨同樣的命運。讓我能抵抗這種命運的最大來源是 Thoughtworks,它定期讓我保持現實感,讓我腳踏實地。&lt;/p>
&lt;p>Thoughtworks also acts as a source of ideas from the field, and I enjoy writing about useful things that my colleagues have discovered and developed. Usually these are helpful ideas, that I hope that some of my readers will be able to use. My topic today isn&amp;rsquo;t such a pleasant topic. It&amp;rsquo;s a problem and one that we don&amp;rsquo;t have an answer for.&lt;/p></description></item><item><title>Tell Dont Ask</title><link>https://easylive1989.github.io/readings/backup/tell-dont-ask/</link><pubDate>Sat, 08 Feb 2025 09:25:28 +0800</pubDate><guid>https://easylive1989.github.io/readings/backup/tell-dont-ask/</guid><description>&lt;p>&lt;a href="https://martinfowler.com/bliki/TellDontAsk.html">Source&lt;/a>&lt;/p>
&lt;p>Tell-Don&amp;rsquo;t-Ask is a principle that helps people remember that object-orientation is about bundling data with the functions that operate on that data. It reminds us that rather than asking an object for data and acting on that data, we should instead tell an object what to do. This encourages to move behavior into an object to go with the data.&lt;/p>
&lt;p>Tell-Don&amp;rsquo;t-Ask 是一個原則，幫助人們記住物件導向是關於將資料與操作該資料的函式捆綁在一起。它提醒我們，與其詢問物件的資料並對該資料進行操作，不如告訴物件要做什麼。這鼓勵將行為移動到與資料相關的物件中。&lt;/p>
&lt;p>&lt;img loading="lazy" src="https://martinfowler.com/bliki/images/tellDontAsk/sketch.png">&lt;/p>
&lt;p>Let&amp;rsquo;s clarify with an example. Let&amp;rsquo;s imagine we need to monitor certain values, signaling an alarm should the value rise above a certain limit. If we write this in an “ask” style, we might have a data structure to represent these things…&lt;/p></description></item><item><title>Unit Test</title><link>https://easylive1989.github.io/readings/backup/unit-test/</link><pubDate>Sat, 08 Feb 2025 09:24:00 +0800</pubDate><guid>https://easylive1989.github.io/readings/backup/unit-test/</guid><description>&lt;p>&lt;a href="https://martinfowler.com/bliki/UnitTest.html">Source&lt;/a>&lt;/p>
&lt;p>Unit testing is often talked about in software development, and is a term that I&amp;rsquo;ve been familiar with during my whole time writing programs. Like most software development terminology, however, it&amp;rsquo;s very ill-defined, and I see confusion can often occur when people think that it&amp;rsquo;s more tightly defined than it actually is.&lt;/p>
&lt;p>單元測試經常在軟體開發中被提及,這是我寫程式時一直熟悉的術語。然而,像大多數軟體開發術語一樣,它的定義非常模糊,我發現當人們認為它的定義比實際更為嚴謹時,往往會引起混淆。&lt;/p>
&lt;p>Although I&amp;rsquo;d done plenty of unit testing before, my definitive exposure was when I started working with Kent Beck and used the Xunit family of unit testing tools. (Indeed I sometimes think a good term for this style of testing might be &amp;ldquo;xunit testing.&amp;rdquo;) Unit testing also became a signature activity of ExtremeProgramming (XP), and led quickly to TestDrivenDevelopment.&lt;/p></description></item><item><title>What if We Rotate Pair Every Day?</title><link>https://easylive1989.github.io/readings/backup/what-if-we-rotate-pair-every-day/</link><pubDate>Sat, 08 Feb 2025 09:02:27 +0800</pubDate><guid>https://easylive1989.github.io/readings/backup/what-if-we-rotate-pair-every-day/</guid><description>&lt;p>&lt;a href="https://martinfowler.com/articles/rotate-pairs-experiment.html">Source&lt;/a>&lt;/p>
&lt;h4 id="unveiling-the-benefits-of-frequent-pair-rotation-through-an-experiment">Unveiling the benefits of frequent pair rotation through an experiment&lt;/h4>
&lt;h4 id="透過實驗揭示頻繁配對輪換的優勢">透過實驗揭示頻繁配對輪換的優勢&lt;/h4>
&lt;p>&lt;em>Benefits of pair programming are widely accepted but advice around pair rotation remains controversial. When and how frequently should teammates rotate pairs? And… What if we rotate pairs every day? We worked with three teams through an exercise of daily pair rotation. We developed a lightweight methodology to help teams reflect on the benefits and challenges of pairing and how to solve them. Initial fears were overcome and teams discovered the benefits of frequently rotating pairs. We learned that pair swapping frequently greatly enhances the benefits of pairing. Here we share the methodology we developed, our observations, and some common fears and insight shared by the participating team members.&lt;/em>&lt;/p></description></item><item><title>Cannot Mesure Productivity</title><link>https://easylive1989.github.io/readings/backup/cannot-mesure-productivity/</link><pubDate>Fri, 07 Feb 2025 16:17:38 +0800</pubDate><guid>https://easylive1989.github.io/readings/backup/cannot-mesure-productivity/</guid><description>&lt;p>&lt;a href="https://www.martinfowler.com/bliki/CannotMeasureProductivity.html">Source&lt;/a>&lt;/p>
&lt;p>We see so much emotional discussion about software process, design practices and the like. Many of these arguments are impossible to resolve because the software industry lacks the ability to measure some of the basic elements of the effectiveness of software development. In particular we have no way of reasonably measuring productivity.&lt;/p>
&lt;p>我們經常看到許多關於軟體流程、設計實踐等方面的情緒化討論。其中許多爭論無法解決，因為軟體產業缺乏衡量軟體開發有效性基本要素的能力。特別是，我們無法合理地衡量生產力。&lt;/p>
&lt;p>Productivity, of course, is something you determine by looking at the input of an activity and its output. So to measure software productivity you have to measure the output of software development - the reason we can&amp;rsquo;t measure productivity is because we can&amp;rsquo;t measure output.&lt;/p></description></item><item><title>Bounded Context</title><link>https://easylive1989.github.io/readings/backup/bounded-context/</link><pubDate>Fri, 07 Feb 2025 15:33:58 +0800</pubDate><guid>https://easylive1989.github.io/readings/backup/bounded-context/</guid><description>&lt;p>&lt;a href="https://martinfowler.com/bliki/BoundedContext.html">Source&lt;/a>&lt;/p>
&lt;p>Bounded Context is a central pattern in Domain-Driven Design. It is the focus of DDD&amp;rsquo;s strategic design section which is all about dealing with large models and teams. DDD deals with large models by dividing them into different Bounded Contexts and being explicit about their interrelationships.&lt;/p>
&lt;p>限界上下文（Bounded Context）是領域驅動設計（Domain-Driven Design, DDD）的核心模式。它是 DDD 戰略設計部分的焦點，主要處理大型模型和團隊。DDD 通過將大型模型劃分為不同的限界上下文，並明確定義它們之間的相互關係，來管理這些龐大的模型。&lt;/p>
&lt;p>&lt;img loading="lazy" src="https://martinfowler.com/bliki/images/boundedContext/sketch.png">&lt;/p>
&lt;p>DDD is about designing software based on models of the underlying domain. A model acts as a &lt;a href="https://martinfowler.com/bliki/UbiquitousLanguage.html">UbiquitousLanguage&lt;/a> to help communication between software developers and domain experts. It also acts as the conceptual foundation for the design of the software itself - how it&amp;rsquo;s broken down into objects or functions. To be effective, a model needs to be unified - that is to be internally consistent so that there are no contradictions within it.&lt;/p></description></item></channel></rss>