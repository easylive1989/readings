<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Martin Fowler on Readings</title><link>https://easylive1989.github.io/readings/tags/martin-fowler/</link><description>Recent content in Martin Fowler on Readings</description><generator>Hugo -- 0.143.1</generator><language>en</language><lastBuildDate>Fri, 07 Feb 2025 16:17:38 +0800</lastBuildDate><atom:link href="https://easylive1989.github.io/readings/tags/martin-fowler/index.xml" rel="self" type="application/rss+xml"/><item><title>Cannot Mesure Productivity</title><link>https://easylive1989.github.io/readings/backup/cannot-mesure-productivity/</link><pubDate>Fri, 07 Feb 2025 16:17:38 +0800</pubDate><guid>https://easylive1989.github.io/readings/backup/cannot-mesure-productivity/</guid><description>&lt;p>&lt;a href="https://www.martinfowler.com/bliki/CannotMeasureProductivity.html">Source&lt;/a>&lt;/p>
&lt;p>We see so much emotional discussion about software process, design practices and the like. Many of these arguments are impossible to resolve because the software industry lacks the ability to measure some of the basic elements of the effectiveness of software development. In particular we have no way of reasonably measuring productivity.&lt;/p>
&lt;p>我們經常看到許多關於軟體流程、設計實踐等方面的情緒化討論。其中許多爭論無法解決，因為軟體產業缺乏衡量軟體開發有效性基本要素的能力。特別是，我們無法合理地衡量生產力。&lt;/p>
&lt;p>Productivity, of course, is something you determine by looking at the input of an activity and its output. So to measure software productivity you have to measure the output of software development - the reason we can&amp;rsquo;t measure productivity is because we can&amp;rsquo;t measure output.&lt;/p></description></item><item><title>Bounded Context</title><link>https://easylive1989.github.io/readings/backup/bounded-context/</link><pubDate>Fri, 07 Feb 2025 15:33:58 +0800</pubDate><guid>https://easylive1989.github.io/readings/backup/bounded-context/</guid><description>&lt;p>&lt;a href="https://martinfowler.com/bliki/BoundedContext.html">Source&lt;/a>&lt;/p>
&lt;p>Bounded Context is a central pattern in Domain-Driven Design. It is the focus of DDD&amp;rsquo;s strategic design section which is all about dealing with large models and teams. DDD deals with large models by dividing them into different Bounded Contexts and being explicit about their interrelationships.&lt;/p>
&lt;p>限界上下文（Bounded Context）是領域驅動設計（Domain-Driven Design, DDD）的核心模式。它是 DDD 戰略設計部分的焦點，主要處理大型模型和團隊。DDD 通過將大型模型劃分為不同的限界上下文，並明確定義它們之間的相互關係，來管理這些龐大的模型。&lt;/p>
&lt;p>&lt;img loading="lazy" src="https://martinfowler.com/bliki/images/boundedContext/sketch.png">&lt;/p>
&lt;p>DDD is about designing software based on models of the underlying domain. A model acts as a &lt;a href="https://martinfowler.com/bliki/UbiquitousLanguage.html">UbiquitousLanguage&lt;/a> to help communication between software developers and domain experts. It also acts as the conceptual foundation for the design of the software itself - how it&amp;rsquo;s broken down into objects or functions. To be effective, a model needs to be unified - that is to be internally consistent so that there are no contradictions within it.&lt;/p></description></item></channel></rss>