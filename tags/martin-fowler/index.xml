<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Martin Fowler on Readings</title><link>https://easylive1989.github.io/readings/tags/martin-fowler/</link><description>Recent content in Martin Fowler on Readings</description><generator>Hugo -- 0.143.1</generator><language>en</language><lastBuildDate>Sat, 08 Feb 2025 09:28:05 +0800</lastBuildDate><atom:link href="https://easylive1989.github.io/readings/tags/martin-fowler/index.xml" rel="self" type="application/rss+xml"/><item><title>Mocks Arent Stubs</title><link>https://easylive1989.github.io/readings/backup/mocks-arent-stubs/</link><pubDate>Sat, 08 Feb 2025 09:28:05 +0800</pubDate><guid>https://easylive1989.github.io/readings/backup/mocks-arent-stubs/</guid><description>&lt;p>&lt;a href="https://martinfowler.com/articles/mocksArentStubs.html">Source&lt;/a>&lt;/p>
&lt;p>The term &amp;lsquo;Mock Objects&amp;rsquo; has become a popular one to describe special case objects that mimic real objects for testing. Most language environments now have frameworks that make it easy to create mock objects. What&amp;rsquo;s often not realized, however, is that mock objects are but one form of special case test object, one that enables a different style of testing. In this article I&amp;rsquo;ll explain how mock objects work, how they encourage testing based on behavior verification, and how the community around them uses them to develop a different style of testing.&lt;/p></description></item><item><title>Test Cancer</title><link>https://easylive1989.github.io/readings/backup/test-cancer/</link><pubDate>Sat, 08 Feb 2025 09:26:48 +0800</pubDate><guid>https://easylive1989.github.io/readings/backup/test-cancer/</guid><description>&lt;p>&lt;a href="https://martinfowler.com/bliki/TestCancer.html">Source&lt;/a>&lt;/p>
&lt;p>As my career has turned into full-time authorship, I often worry about distancing myself from the realities of day-to-day software development. I&amp;rsquo;ve seen other well-known figures lose contact with reality, and I fear the same fate. My greatest source of resistance to this is Thoughtworks, which acts as a regular dose of reality to keep my feet on the ground.&lt;/p>
&lt;p>隨著我的職業生涯逐漸轉向全職作者,我經常擔心自己會脫離日常軟體開發的現實。我見過其他知名人物失去與現實的聯繫,而我也擔心自己會面臨同樣的命運。讓我能抵抗這種命運的最大來源是 Thoughtworks,它定期讓我保持現實感,讓我腳踏實地。&lt;/p>
&lt;p>Thoughtworks also acts as a source of ideas from the field, and I enjoy writing about useful things that my colleagues have discovered and developed. Usually these are helpful ideas, that I hope that some of my readers will be able to use. My topic today isn&amp;rsquo;t such a pleasant topic. It&amp;rsquo;s a problem and one that we don&amp;rsquo;t have an answer for.&lt;/p></description></item><item><title>Tell Dont Ask</title><link>https://easylive1989.github.io/readings/backup/tell-dont-ask/</link><pubDate>Sat, 08 Feb 2025 09:25:28 +0800</pubDate><guid>https://easylive1989.github.io/readings/backup/tell-dont-ask/</guid><description>&lt;p>&lt;a href="https://martinfowler.com/bliki/TellDontAsk.html">Source&lt;/a>&lt;/p>
&lt;p>Tell-Don&amp;rsquo;t-Ask is a principle that helps people remember that object-orientation is about bundling data with the functions that operate on that data. It reminds us that rather than asking an object for data and acting on that data, we should instead tell an object what to do. This encourages to move behavior into an object to go with the data.&lt;/p>
&lt;p>Tell-Don&amp;rsquo;t-Ask 是一個原則，幫助人們記住物件導向是關於將資料與操作該資料的函式捆綁在一起。它提醒我們，與其詢問物件的資料並對該資料進行操作，不如告訴物件要做什麼。這鼓勵將行為移動到與資料相關的物件中。&lt;/p>
&lt;p>&lt;img loading="lazy" src="https://martinfowler.com/bliki/images/tellDontAsk/sketch.png">&lt;/p>
&lt;p>Let&amp;rsquo;s clarify with an example. Let&amp;rsquo;s imagine we need to monitor certain values, signaling an alarm should the value rise above a certain limit. If we write this in an “ask” style, we might have a data structure to represent these things…&lt;/p></description></item><item><title>Unit Test</title><link>https://easylive1989.github.io/readings/backup/unit-test/</link><pubDate>Sat, 08 Feb 2025 09:24:00 +0800</pubDate><guid>https://easylive1989.github.io/readings/backup/unit-test/</guid><description>&lt;p>&lt;a href="https://martinfowler.com/bliki/UnitTest.html">Source&lt;/a>&lt;/p>
&lt;p>Unit testing is often talked about in software development, and is a term that I&amp;rsquo;ve been familiar with during my whole time writing programs. Like most software development terminology, however, it&amp;rsquo;s very ill-defined, and I see confusion can often occur when people think that it&amp;rsquo;s more tightly defined than it actually is.&lt;/p>
&lt;p>單元測試經常在軟體開發中被提及,這是我寫程式時一直熟悉的術語。然而,像大多數軟體開發術語一樣,它的定義非常模糊,我發現當人們認為它的定義比實際更為嚴謹時,往往會引起混淆。&lt;/p>
&lt;p>Although I&amp;rsquo;d done plenty of unit testing before, my definitive exposure was when I started working with Kent Beck and used the Xunit family of unit testing tools. (Indeed I sometimes think a good term for this style of testing might be &amp;ldquo;xunit testing.&amp;rdquo;) Unit testing also became a signature activity of ExtremeProgramming (XP), and led quickly to TestDrivenDevelopment.&lt;/p></description></item><item><title>What if We Rotate Pair Every Day?</title><link>https://easylive1989.github.io/readings/backup/what-if-we-rotate-pair-every-day/</link><pubDate>Sat, 08 Feb 2025 09:02:27 +0800</pubDate><guid>https://easylive1989.github.io/readings/backup/what-if-we-rotate-pair-every-day/</guid><description>&lt;p>&lt;a href="https://martinfowler.com/articles/rotate-pairs-experiment.html">Source&lt;/a>&lt;/p>
&lt;h4 id="unveiling-the-benefits-of-frequent-pair-rotation-through-an-experiment">Unveiling the benefits of frequent pair rotation through an experiment&lt;/h4>
&lt;h4 id="透過實驗揭示頻繁配對輪換的優勢">透過實驗揭示頻繁配對輪換的優勢&lt;/h4>
&lt;p>&lt;em>Benefits of pair programming are widely accepted but advice around pair rotation remains controversial. When and how frequently should teammates rotate pairs? And… What if we rotate pairs every day? We worked with three teams through an exercise of daily pair rotation. We developed a lightweight methodology to help teams reflect on the benefits and challenges of pairing and how to solve them. Initial fears were overcome and teams discovered the benefits of frequently rotating pairs. We learned that pair swapping frequently greatly enhances the benefits of pairing. Here we share the methodology we developed, our observations, and some common fears and insight shared by the participating team members.&lt;/em>&lt;/p></description></item><item><title>Cannot Mesure Productivity</title><link>https://easylive1989.github.io/readings/backup/cannot-mesure-productivity/</link><pubDate>Fri, 07 Feb 2025 16:17:38 +0800</pubDate><guid>https://easylive1989.github.io/readings/backup/cannot-mesure-productivity/</guid><description>&lt;p>&lt;a href="https://www.martinfowler.com/bliki/CannotMeasureProductivity.html">Source&lt;/a>&lt;/p>
&lt;p>We see so much emotional discussion about software process, design practices and the like. Many of these arguments are impossible to resolve because the software industry lacks the ability to measure some of the basic elements of the effectiveness of software development. In particular we have no way of reasonably measuring productivity.&lt;/p>
&lt;p>我們經常看到許多關於軟體流程、設計實踐等方面的情緒化討論。其中許多爭論無法解決，因為軟體產業缺乏衡量軟體開發有效性基本要素的能力。特別是，我們無法合理地衡量生產力。&lt;/p>
&lt;p>Productivity, of course, is something you determine by looking at the input of an activity and its output. So to measure software productivity you have to measure the output of software development - the reason we can&amp;rsquo;t measure productivity is because we can&amp;rsquo;t measure output.&lt;/p></description></item><item><title>Bounded Context</title><link>https://easylive1989.github.io/readings/backup/bounded-context/</link><pubDate>Fri, 07 Feb 2025 15:33:58 +0800</pubDate><guid>https://easylive1989.github.io/readings/backup/bounded-context/</guid><description>&lt;p>&lt;a href="https://martinfowler.com/bliki/BoundedContext.html">Source&lt;/a>&lt;/p>
&lt;p>Bounded Context is a central pattern in Domain-Driven Design. It is the focus of DDD&amp;rsquo;s strategic design section which is all about dealing with large models and teams. DDD deals with large models by dividing them into different Bounded Contexts and being explicit about their interrelationships.&lt;/p>
&lt;p>限界上下文（Bounded Context）是領域驅動設計（Domain-Driven Design, DDD）的核心模式。它是 DDD 戰略設計部分的焦點，主要處理大型模型和團隊。DDD 通過將大型模型劃分為不同的限界上下文，並明確定義它們之間的相互關係，來管理這些龐大的模型。&lt;/p>
&lt;p>&lt;img loading="lazy" src="https://martinfowler.com/bliki/images/boundedContext/sketch.png">&lt;/p>
&lt;p>DDD is about designing software based on models of the underlying domain. A model acts as a &lt;a href="https://martinfowler.com/bliki/UbiquitousLanguage.html">UbiquitousLanguage&lt;/a> to help communication between software developers and domain experts. It also acts as the conceptual foundation for the design of the software itself - how it&amp;rsquo;s broken down into objects or functions. To be effective, a model needs to be unified - that is to be internally consistent so that there are no contradictions within it.&lt;/p></description></item></channel></rss>